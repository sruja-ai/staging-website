import{p as Hi}from"./react-vendor-SGOvMy1P.js";import{L as On,t as Ji,_ as Kt,n as de,i as Yi,a as Qi,b as Xi,c as qt,d as F,e as $,s as mt,f as R,u as P,g as se,h as $e,j as Ln,k as re,l as Zi,p as Le,m as un,o as xt,q as He,r as ce,v as L,w as ue,x as er,y as tr,z as nr,A as ir,B as Wn,C as oe,D as le,E as dn,F as K,G as rr,H as Bt,I as Tn,J as Se,K as jn,M as Pn,N as Rt,O as We,P as M,Q as C,R as zn,S as Un,T as sr,U as Z,V as yt,W as Mt,X as ln,Y as Fn,Z as ie,$ as Kn,a0 as or,a1 as wt,a2 as qn,a3 as Je,a4 as j,a5 as ar,a6 as Ce,a7 as D,a8 as Bn,a9 as J,aa as Te,ab as Vn,ac as hn,ad as cr,ae as fn,af as xe,ag as Vt,ah as ke,ai as Hn,aj as Jn,ak as Yn,al as Q,am as ur,an as dr,ao as lr,ap as pn,aq as Ot,ar as ee,as as ge,at as hr,au as Qn,av as bt,aw as gn,ax as Ne,ay as Xn,az as fr,aA as pr,aB as mn,aC as gr,aD as mr,aE as Ye,aF as Zn,aG as yr,aH as ei,aI as wr,aJ as br,aK as Er,aL as vr,aM as $r,aN as xr,aO as _r,aP as kr,aQ as Sr,aR as Dr,aS as Gr,aT as Cr,aU as Ar,aV as Ir,aW as Nr,aX as Rr}from"./diagram-vendor-S_kKKzx8.js";class nt extends Error{constructor(e,t){super(e),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"context",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name="SrujaError",this.code=t?.code??"UNKNOWN_ERROR",this.context=t?.context,this.cause=t?.cause,Error.captureStackTrace&&Error.captureStackTrace(this,nt)}toJSON(){const e={name:this.name,message:this.message,code:this.code,context:this.context,stack:this.stack};return this.cause&&(e.cause={name:this.cause.name,message:this.cause.message,stack:this.cause.stack}),e}}class Re extends nt{constructor(e,t){super(e,{code:"CONFIGURATION_ERROR",context:{...t?.context,configKey:t?.configKey}}),this.name="ConfigurationError"}}class Et extends nt{constructor(e,t){super(e,{code:"NETWORK_ERROR",context:{...t?.context,url:t?.url,status:t?.status},cause:t?.cause}),this.name="NetworkError"}}const Mr="sruja-project",Or="sruja-project";let Lr=null;function ti(){if(typeof window<"u"){const i=window;if(i.posthog)return i.posthog}return Lr}function ni(i,e){const t=ti();t&&typeof t.capture=="function"&&t.capture(i,e||{})}var Wr={};let Lt=!1,ii;const Wt=typeof Hi<"u"&&Wr!==void 0&&!0;function Tr(){if(Lt)return!0;if(typeof window<"u"){const i=window.__SRUJA_DEBUG__;if(typeof i=="boolean")return i;try{if(window.localStorage?.getItem("sruja:debug")==="true")return!0}catch{}}return!Wt}function yn(i){return[i.timestamp,`[${i.level.toUpperCase()}]`,i.service?`[${i.service}]`:"",i.message].filter(Boolean).join(" ")}function wn(i){const e={timestamp:i.timestamp,level:i.level,message:i.message};return i.service&&(e.service=i.service),i.context&&Object.keys(i.context).length>0&&(e.context=i.context),JSON.stringify(e)}function at(i,e,t){const n=new Date().toISOString(),r={level:i,message:e,context:t,timestamp:n,service:ii};if(i==="error"||i==="warn"){const o=Wt?wn(r):yn(r);if(i==="error"){console.error(o,t?JSON.stringify(t,null,2):"");try{const a=(typeof t?.component=="string"?t.component:void 0)||"unknown",c=(typeof t?.action=="string"?t.action:void 0)||"error",u=`error.${a}.${c}`,d={error_message:e,error_type:(typeof t?.errorType=="string"?t.errorType:void 0)||"unknown",...t};typeof window<"u"&&(d.user_agent=navigator.userAgent,d.screen_size=`${window.screen.width}x${window.screen.height}`,d.viewport_size=`${window.innerWidth}x${window.innerHeight}`,d.url=window.location.href.substring(0,200)),ni(u,d)}catch{}}else console.warn(o,t?JSON.stringify(t,null,2):"");return}if(!Tr())return;const s=Wt?wn(r):yn(r);i==="info"?console.info(s,t?JSON.stringify(t,null,2):""):console.debug(s,t?JSON.stringify(t,null,2):"")}const T={setService(i){ii=i},enableDebug(){Lt=!0},disableDebug(){Lt=!1},debug(i,e){at("debug",i,e)},info(i,e){at("info",i,e)},warn(i,e){at("warn",i,e)},error(i,e){at("error",i,e)}};function it(){return typeof window<"u"}function _t(i){if(!it())return i?.trailingSlash?"/":"";const e=import.meta;if(e.env?.BASE_URL){const s=e.env.BASE_URL;return i?.trailingSlash?s.endsWith("/")?s:s+"/":s.endsWith("/")?s.slice(0,-1):s}const t=window.location.pathname;if(i?.studioPath!==!1&&t.startsWith("/studio"))return i?.trailingSlash?"/":"";const n=t.match(/^(\/.+?)\//),r=n?n[1]:"";return i?.trailingSlash?r?r+"/":"/":r}var ct={exports:{}},bn;function jr(){if(bn)return ct.exports;bn=1;var i=typeof Reflect=="object"?Reflect:null,e=i&&typeof i.apply=="function"?i.apply:function(p,y,E){return Function.prototype.apply.call(p,y,E)},t;i&&typeof i.ownKeys=="function"?t=i.ownKeys:Object.getOwnPropertySymbols?t=function(p){return Object.getOwnPropertyNames(p).concat(Object.getOwnPropertySymbols(p))}:t=function(p){return Object.getOwnPropertyNames(p)};function n(g){console&&console.warn&&console.warn(g)}var r=Number.isNaN||function(p){return p!==p};function s(){s.init.call(this)}ct.exports=s,ct.exports.once=A,s.EventEmitter=s,s.prototype._events=void 0,s.prototype._eventsCount=0,s.prototype._maxListeners=void 0;var o=10;function a(g){if(typeof g!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof g)}Object.defineProperty(s,"defaultMaxListeners",{enumerable:!0,get:function(){return o},set:function(g){if(typeof g!="number"||g<0||r(g))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+g+".");o=g}}),s.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},s.prototype.setMaxListeners=function(p){if(typeof p!="number"||p<0||r(p))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+p+".");return this._maxListeners=p,this};function c(g){return g._maxListeners===void 0?s.defaultMaxListeners:g._maxListeners}s.prototype.getMaxListeners=function(){return c(this)},s.prototype.emit=function(p){for(var y=[],E=1;E<arguments.length;E++)y.push(arguments[E]);var _=p==="error",I=this._events;if(I!==void 0)_=_&&I.error===void 0;else if(!_)return!1;if(_){var G;if(y.length>0&&(G=y[0]),G instanceof Error)throw G;var H=new Error("Unhandled error."+(G?" ("+G.message+")":""));throw H.context=G,H}var W=I[p];if(W===void 0)return!1;if(typeof W=="function")e(W,this,y);else for(var Y=W.length,ot=m(W,Y),E=0;E<Y;++E)e(ot[E],this,y);return!0};function u(g,p,y,E){var _,I,G;if(a(y),I=g._events,I===void 0?(I=g._events=Object.create(null),g._eventsCount=0):(I.newListener!==void 0&&(g.emit("newListener",p,y.listener?y.listener:y),I=g._events),G=I[p]),G===void 0)G=I[p]=y,++g._eventsCount;else if(typeof G=="function"?G=I[p]=E?[y,G]:[G,y]:E?G.unshift(y):G.push(y),_=c(g),_>0&&G.length>_&&!G.warned){G.warned=!0;var H=new Error("Possible EventEmitter memory leak detected. "+G.length+" "+String(p)+" listeners added. Use emitter.setMaxListeners() to increase limit");H.name="MaxListenersExceededWarning",H.emitter=g,H.type=p,H.count=G.length,n(H)}return g}s.prototype.addListener=function(p,y){return u(this,p,y,!1)},s.prototype.on=s.prototype.addListener,s.prototype.prependListener=function(p,y){return u(this,p,y,!0)};function d(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function l(g,p,y){var E={fired:!1,wrapFn:void 0,target:g,type:p,listener:y},_=d.bind(E);return _.listener=y,E.wrapFn=_,_}s.prototype.once=function(p,y){return a(y),this.on(p,l(this,p,y)),this},s.prototype.prependOnceListener=function(p,y){return a(y),this.prependListener(p,l(this,p,y)),this},s.prototype.removeListener=function(p,y){var E,_,I,G,H;if(a(y),_=this._events,_===void 0)return this;if(E=_[p],E===void 0)return this;if(E===y||E.listener===y)--this._eventsCount===0?this._events=Object.create(null):(delete _[p],_.removeListener&&this.emit("removeListener",p,E.listener||y));else if(typeof E!="function"){for(I=-1,G=E.length-1;G>=0;G--)if(E[G]===y||E[G].listener===y){H=E[G].listener,I=G;break}if(I<0)return this;I===0?E.shift():x(E,I),E.length===1&&(_[p]=E[0]),_.removeListener!==void 0&&this.emit("removeListener",p,H||y)}return this},s.prototype.off=s.prototype.removeListener,s.prototype.removeAllListeners=function(p){var y,E,_;if(E=this._events,E===void 0)return this;if(E.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):E[p]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete E[p]),this;if(arguments.length===0){var I=Object.keys(E),G;for(_=0;_<I.length;++_)G=I[_],G!=="removeListener"&&this.removeAllListeners(G);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(y=E[p],typeof y=="function")this.removeListener(p,y);else if(y!==void 0)for(_=y.length-1;_>=0;_--)this.removeListener(p,y[_]);return this};function h(g,p,y){var E=g._events;if(E===void 0)return[];var _=E[p];return _===void 0?[]:typeof _=="function"?y?[_.listener||_]:[_]:y?b(_):m(_,_.length)}s.prototype.listeners=function(p){return h(this,p,!0)},s.prototype.rawListeners=function(p){return h(this,p,!1)},s.listenerCount=function(g,p){return typeof g.listenerCount=="function"?g.listenerCount(p):f.call(g,p)},s.prototype.listenerCount=f;function f(g){var p=this._events;if(p!==void 0){var y=p[g];if(typeof y=="function")return 1;if(y!==void 0)return y.length}return 0}s.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]};function m(g,p){for(var y=new Array(p),E=0;E<p;++E)y[E]=g[E];return y}function x(g,p){for(;p+1<g.length;p++)g[p]=g[p+1];g.pop()}function b(g){for(var p=new Array(g.length),y=0;y<p.length;++y)p[y]=g[y].listener||g[y];return p}function A(g,p){return new Promise(function(y,E){function _(G){g.removeListener(p,I),E(G)}function I(){typeof g.removeListener=="function"&&g.removeListener("error",_),y([].slice.call(arguments))}N(g,p,I,{once:!0}),p!=="error"&&S(g,_,{once:!0})})}function S(g,p,y){typeof g.on=="function"&&N(g,"error",p,y)}function N(g,p,y,E){if(typeof g.on=="function")E.once?g.once(p,y):g.on(p,y);else if(typeof g.addEventListener=="function")g.addEventListener(p,function _(I){E.once&&g.removeEventListener(p,_),y(I)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof g)}return ct.exports}var Pr=jr();function zr(){const i=arguments[0];for(let e=1,t=arguments.length;e<t;e++)if(arguments[e])for(const n in arguments[e])i[n]=arguments[e][n];return i}let U=zr;typeof Object.assign=="function"&&(U=Object.assign);function ae(i,e,t,n){const r=i._nodes.get(e);let s=null;return r&&(n==="mixed"?s=r.out&&r.out[t]||r.undirected&&r.undirected[t]:n==="directed"?s=r.out&&r.out[t]:s=r.undirected&&r.undirected[t]),s}function B(i){return typeof i=="object"&&i!==null}function ri(i){let e;for(e in i)return!1;return!0}function ne(i,e,t){Object.defineProperty(i,e,{enumerable:!1,configurable:!1,writable:!0,value:t})}function he(i,e,t){const n={enumerable:!0,configurable:!0};typeof t=="function"?n.get=t:(n.value=t,n.writable=!1),Object.defineProperty(i,e,n)}function En(i){return!(!B(i)||i.attributes&&!Array.isArray(i.attributes))}function Ur(){let i=Math.floor(Math.random()*256)&255;return()=>i++}function we(){const i=arguments;let e=null,t=-1;return{[Symbol.iterator](){return this},next(){let n=null;do{if(e===null){if(t++,t>=i.length)return{done:!0};e=i[t][Symbol.iterator]()}if(n=e.next(),n.done){e=null;continue}break}while(!0);return n}}}function je(){return{[Symbol.iterator](){return this},next(){return{done:!0}}}}class Ht extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class v extends Ht{constructor(e){super(e),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,v.prototype.constructor)}}class w extends Ht{constructor(e){super(e),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,w.prototype.constructor)}}class k extends Ht{constructor(e){super(e),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,k.prototype.constructor)}}function si(i,e){this.key=i,this.attributes=e,this.clear()}si.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}};function oi(i,e){this.key=i,this.attributes=e,this.clear()}oi.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}};function ai(i,e){this.key=i,this.attributes=e,this.clear()}ai.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}};function Pe(i,e,t,n,r){this.key=e,this.attributes=r,this.undirected=i,this.source=t,this.target=n}Pe.prototype.attach=function(){let i="out",e="in";this.undirected&&(i=e="undirected");const t=this.source.key,n=this.target.key;this.source[i][n]=this,!(this.undirected&&t===n)&&(this.target[e][t]=this)};Pe.prototype.attachMulti=function(){let i="out",e="in";const t=this.source.key,n=this.target.key;this.undirected&&(i=e="undirected");const r=this.source[i],s=r[n];if(typeof s>"u"){r[n]=this,this.undirected&&t===n||(this.target[e][t]=this);return}s.previous=this,this.next=s,r[n]=this,this.target[e][t]=this};Pe.prototype.detach=function(){const i=this.source.key,e=this.target.key;let t="out",n="in";this.undirected&&(t=n="undirected"),delete this.source[t][e],delete this.target[n][i]};Pe.prototype.detachMulti=function(){const i=this.source.key,e=this.target.key;let t="out",n="in";this.undirected&&(t=n="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[t][e],delete this.target[n][i]):(this.next.previous=void 0,this.source[t][e]=this.next,this.target[n][i]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const ci=0,ui=1,Fr=2,di=3;function be(i,e,t,n,r,s,o){let a,c,u,d;if(n=""+n,t===ci){if(a=i._nodes.get(n),!a)throw new w(`Graph.${e}: could not find the "${n}" node in the graph.`);u=r,d=s}else if(t===di){if(r=""+r,c=i._edges.get(r),!c)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`);const l=c.source.key,h=c.target.key;if(n===l)a=c.target;else if(n===h)a=c.source;else throw new w(`Graph.${e}: the "${n}" node is not attached to the "${r}" edge (${l}, ${h}).`);u=s,d=o}else{if(c=i._edges.get(n),!c)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`);t===ui?a=c.source:a=c.target,u=r,d=s}return[a,u,d]}function Kr(i,e,t){i.prototype[e]=function(n,r,s){const[o,a]=be(this,e,t,n,r,s);return o.attributes[a]}}function qr(i,e,t){i.prototype[e]=function(n,r){const[s]=be(this,e,t,n,r);return s.attributes}}function Br(i,e,t){i.prototype[e]=function(n,r,s){const[o,a]=be(this,e,t,n,r,s);return o.attributes.hasOwnProperty(a)}}function Vr(i,e,t){i.prototype[e]=function(n,r,s,o){const[a,c,u]=be(this,e,t,n,r,s,o);return a.attributes[c]=u,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:c}),this}}function Hr(i,e,t){i.prototype[e]=function(n,r,s,o){const[a,c,u]=be(this,e,t,n,r,s,o);if(typeof u!="function")throw new v(`Graph.${e}: updater should be a function.`);const d=a.attributes,l=u(d[c]);return d[c]=l,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:c}),this}}function Jr(i,e,t){i.prototype[e]=function(n,r,s){const[o,a]=be(this,e,t,n,r,s);return delete o.attributes[a],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:a}),this}}function Yr(i,e,t){i.prototype[e]=function(n,r,s){const[o,a]=be(this,e,t,n,r,s);if(!B(a))throw new v(`Graph.${e}: provided attributes are not a plain object.`);return o.attributes=a,this.emit("nodeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}function Qr(i,e,t){i.prototype[e]=function(n,r,s){const[o,a]=be(this,e,t,n,r,s);if(!B(a))throw new v(`Graph.${e}: provided attributes are not a plain object.`);return U(o.attributes,a),this.emit("nodeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:a}),this}}function Xr(i,e,t){i.prototype[e]=function(n,r,s){const[o,a]=be(this,e,t,n,r,s);if(typeof a!="function")throw new v(`Graph.${e}: provided updater is not a function.`);return o.attributes=a(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}const Zr=[{name:i=>`get${i}Attribute`,attacher:Kr},{name:i=>`get${i}Attributes`,attacher:qr},{name:i=>`has${i}Attribute`,attacher:Br},{name:i=>`set${i}Attribute`,attacher:Vr},{name:i=>`update${i}Attribute`,attacher:Hr},{name:i=>`remove${i}Attribute`,attacher:Jr},{name:i=>`replace${i}Attributes`,attacher:Yr},{name:i=>`merge${i}Attributes`,attacher:Qr},{name:i=>`update${i}Attributes`,attacher:Xr}];function es(i){Zr.forEach(function({name:e,attacher:t}){t(i,e("Node"),ci),t(i,e("Source"),ui),t(i,e("Target"),Fr),t(i,e("Opposite"),di)})}function ts(i,e,t){i.prototype[e]=function(n,r){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new k(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new k(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+n,a=""+r;if(r=arguments[2],s=ae(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new k(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,s=this._edges.get(n),!s)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`)}return s.attributes[r]}}function ns(i,e,t){i.prototype[e]=function(n){let r;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new k(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new k(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+n,o=""+arguments[1];if(r=ae(this,s,o,t),!r)throw new w(`Graph.${e}: could not find an edge for the given path ("${s}" - "${o}").`)}else{if(t!=="mixed")throw new k(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,r=this._edges.get(n),!r)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`)}return r.attributes}}function is(i,e,t){i.prototype[e]=function(n,r){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new k(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new k(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+n,a=""+r;if(r=arguments[2],s=ae(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new k(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,s=this._edges.get(n),!s)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`)}return s.attributes.hasOwnProperty(r)}}function rs(i,e,t){i.prototype[e]=function(n,r,s){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new k(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new k(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+n,c=""+r;if(r=arguments[2],s=arguments[3],o=ae(this,a,c,t),!o)throw new w(`Graph.${e}: could not find an edge for the given path ("${a}" - "${c}").`)}else{if(t!=="mixed")throw new k(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`)}return o.attributes[r]=s,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}function ss(i,e,t){i.prototype[e]=function(n,r,s){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new k(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new k(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+n,c=""+r;if(r=arguments[2],s=arguments[3],o=ae(this,a,c,t),!o)throw new w(`Graph.${e}: could not find an edge for the given path ("${a}" - "${c}").`)}else{if(t!=="mixed")throw new k(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`)}if(typeof s!="function")throw new v(`Graph.${e}: updater should be a function.`);return o.attributes[r]=s(o.attributes[r]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}function os(i,e,t){i.prototype[e]=function(n,r){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new k(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new k(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+n,a=""+r;if(r=arguments[2],s=ae(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new k(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,s=this._edges.get(n),!s)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`)}return delete s.attributes[r],this.emit("edgeAttributesUpdated",{key:s.key,type:"remove",attributes:s.attributes,name:r}),this}}function as(i,e,t){i.prototype[e]=function(n,r){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new k(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new k(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+n,a=""+r;if(r=arguments[2],s=ae(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new k(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,s=this._edges.get(n),!s)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`)}if(!B(r))throw new v(`Graph.${e}: provided attributes are not a plain object.`);return s.attributes=r,this.emit("edgeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}function cs(i,e,t){i.prototype[e]=function(n,r){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new k(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new k(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+n,a=""+r;if(r=arguments[2],s=ae(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new k(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,s=this._edges.get(n),!s)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`)}if(!B(r))throw new v(`Graph.${e}: provided attributes are not a plain object.`);return U(s.attributes,r),this.emit("edgeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:r}),this}}function us(i,e,t){i.prototype[e]=function(n,r){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new k(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new k(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+n,a=""+r;if(r=arguments[2],s=ae(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new k(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,s=this._edges.get(n),!s)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`)}if(typeof r!="function")throw new v(`Graph.${e}: provided updater is not a function.`);return s.attributes=r(s.attributes),this.emit("edgeAttributesUpdated",{key:s.key,type:"update",attributes:s.attributes}),this}}const ds=[{name:i=>`get${i}Attribute`,attacher:ts},{name:i=>`get${i}Attributes`,attacher:ns},{name:i=>`has${i}Attribute`,attacher:is},{name:i=>`set${i}Attribute`,attacher:rs},{name:i=>`update${i}Attribute`,attacher:ss},{name:i=>`remove${i}Attribute`,attacher:os},{name:i=>`replace${i}Attributes`,attacher:as},{name:i=>`merge${i}Attributes`,attacher:cs},{name:i=>`update${i}Attributes`,attacher:us}];function ls(i){ds.forEach(function({name:e,attacher:t}){t(i,e("Edge"),"mixed"),t(i,e("DirectedEdge"),"directed"),t(i,e("UndirectedEdge"),"undirected")})}const hs=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function fs(i,e,t,n){let r=!1;for(const s in e){if(s===n)continue;const o=e[s];if(r=t(o.key,o.attributes,o.source.key,o.target.key,o.source.attributes,o.target.attributes,o.undirected),i&&r)return o.key}}function ps(i,e,t,n){let r,s,o,a=!1;for(const c in e)if(c!==n){r=e[c];do{if(s=r.source,o=r.target,a=t(r.key,r.attributes,s.key,o.key,s.attributes,o.attributes,r.undirected),i&&a)return r.key;r=r.next}while(r!==void 0)}}function Dt(i,e){const t=Object.keys(i),n=t.length;let r,s=0;return{[Symbol.iterator](){return this},next(){do if(r)r=r.next;else{if(s>=n)return{done:!0};const o=t[s++];if(o===e){r=void 0;continue}r=i[o]}while(!r);return{done:!1,value:{edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected}}}}}function gs(i,e,t,n){const r=e[t];if(!r)return;const s=r.source,o=r.target;if(n(r.key,r.attributes,s.key,o.key,s.attributes,o.attributes,r.undirected)&&i)return r.key}function ms(i,e,t,n){let r=e[t];if(!r)return;let s=!1;do{if(s=n(r.key,r.attributes,r.source.key,r.target.key,r.source.attributes,r.target.attributes,r.undirected),i&&s)return r.key;r=r.next}while(r!==void 0)}function Gt(i,e){let t=i[e];if(t.next!==void 0)return{[Symbol.iterator](){return this},next(){if(!t)return{done:!0};const r={edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected};return t=t.next,{done:!1,value:r}}};let n=!1;return{[Symbol.iterator](){return this},next(){return n===!0?{done:!0}:(n=!0,{done:!1,value:{edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected}})}}}function ys(i,e){if(i.size===0)return[];if(e==="mixed"||e===i.type)return Array.from(i._edges.keys());const t=e==="undirected"?i.undirectedSize:i.directedSize,n=new Array(t),r=e==="undirected",s=i._edges.values();let o=0,a,c;for(;a=s.next(),a.done!==!0;)c=a.value,c.undirected===r&&(n[o++]=c.key);return n}function li(i,e,t,n){if(e.size===0)return;const r=t!=="mixed"&&t!==e.type,s=t==="undirected";let o,a,c=!1;const u=e._edges.values();for(;o=u.next(),o.done!==!0;){if(a=o.value,r&&a.undirected!==s)continue;const{key:d,attributes:l,source:h,target:f}=a;if(c=n(d,l,h.key,f.key,h.attributes,f.attributes,a.undirected),i&&c)return d}}function ws(i,e){if(i.size===0)return je();const t=e!=="mixed"&&e!==i.type,n=e==="undirected",r=i._edges.values();return{[Symbol.iterator](){return this},next(){let s,o;for(;;){if(s=r.next(),s.done)return s;if(o=s.value,!(t&&o.undirected!==n))break}return{value:{edge:o.key,attributes:o.attributes,source:o.source.key,target:o.target.key,sourceAttributes:o.source.attributes,targetAttributes:o.target.attributes,undirected:o.undirected},done:!1}}}}function Jt(i,e,t,n,r,s){const o=e?ps:fs;let a;if(t!=="undirected"&&(n!=="out"&&(a=o(i,r.in,s),i&&a)||n!=="in"&&(a=o(i,r.out,s,n?void 0:r.key),i&&a))||t!=="directed"&&(a=o(i,r.undirected,s),i&&a))return a}function bs(i,e,t,n){const r=[];return Jt(!1,i,e,t,n,function(s){r.push(s)}),r}function Es(i,e,t){let n=je();return i!=="undirected"&&(e!=="out"&&typeof t.in<"u"&&(n=we(n,Dt(t.in))),e!=="in"&&typeof t.out<"u"&&(n=we(n,Dt(t.out,e?void 0:t.key)))),i!=="directed"&&typeof t.undirected<"u"&&(n=we(n,Dt(t.undirected))),n}function Yt(i,e,t,n,r,s,o){const a=t?ms:gs;let c;if(e!=="undirected"&&(typeof r.in<"u"&&n!=="out"&&(c=a(i,r.in,s,o),i&&c)||typeof r.out<"u"&&n!=="in"&&(n||r.key!==s)&&(c=a(i,r.out,s,o),i&&c))||e!=="directed"&&typeof r.undirected<"u"&&(c=a(i,r.undirected,s,o),i&&c))return c}function vs(i,e,t,n,r){const s=[];return Yt(!1,i,e,t,n,r,function(o){s.push(o)}),s}function $s(i,e,t,n){let r=je();return i!=="undirected"&&(typeof t.in<"u"&&e!=="out"&&n in t.in&&(r=we(r,Gt(t.in,n))),typeof t.out<"u"&&e!=="in"&&n in t.out&&(e||t.key!==n)&&(r=we(r,Gt(t.out,n)))),i!=="directed"&&typeof t.undirected<"u"&&n in t.undirected&&(r=we(r,Gt(t.undirected,n))),r}function xs(i,e){const{name:t,type:n,direction:r}=e;i.prototype[t]=function(s,o){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return[];if(!arguments.length)return ys(this,n);if(arguments.length===1){s=""+s;const a=this._nodes.get(s);if(typeof a>"u")throw new w(`Graph.${t}: could not find the "${s}" node in the graph.`);return bs(this.multi,n==="mixed"?this.type:n,r,a)}if(arguments.length===2){s=""+s,o=""+o;const a=this._nodes.get(s);if(!a)throw new w(`Graph.${t}:  could not find the "${s}" source node in the graph.`);if(!this._nodes.has(o))throw new w(`Graph.${t}:  could not find the "${o}" target node in the graph.`);return vs(n,this.multi,r,a,o)}throw new v(`Graph.${t}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function _s(i,e){const{name:t,type:n,direction:r}=e,s="forEach"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(u,d,l){if(!(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)){if(arguments.length===1)return l=u,li(!1,this,n,l);if(arguments.length===2){u=""+u,l=d;const h=this._nodes.get(u);if(typeof h>"u")throw new w(`Graph.${s}: could not find the "${u}" node in the graph.`);return Jt(!1,this.multi,n==="mixed"?this.type:n,r,h,l)}if(arguments.length===3){u=""+u,d=""+d;const h=this._nodes.get(u);if(!h)throw new w(`Graph.${s}:  could not find the "${u}" source node in the graph.`);if(!this._nodes.has(d))throw new w(`Graph.${s}:  could not find the "${d}" target node in the graph.`);return Yt(!1,n,this.multi,r,h,d,l)}throw new v(`Graph.${s}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const o="map"+t[0].toUpperCase()+t.slice(1);i.prototype[o]=function(){const u=Array.prototype.slice.call(arguments),d=u.pop();let l;if(u.length===0){let h=0;n!=="directed"&&(h+=this.undirectedSize),n!=="undirected"&&(h+=this.directedSize),l=new Array(h);let f=0;u.push((m,x,b,A,S,N,g)=>{l[f++]=d(m,x,b,A,S,N,g)})}else l=[],u.push((h,f,m,x,b,A,S)=>{l.push(d(h,f,m,x,b,A,S))});return this[s].apply(this,u),l};const a="filter"+t[0].toUpperCase()+t.slice(1);i.prototype[a]=function(){const u=Array.prototype.slice.call(arguments),d=u.pop(),l=[];return u.push((h,f,m,x,b,A,S)=>{d(h,f,m,x,b,A,S)&&l.push(h)}),this[s].apply(this,u),l};const c="reduce"+t[0].toUpperCase()+t.slice(1);i.prototype[c]=function(){let u=Array.prototype.slice.call(arguments);if(u.length<2||u.length>4)throw new v(`Graph.${c}: invalid number of arguments (expecting 2, 3 or 4 and got ${u.length}).`);if(typeof u[u.length-1]=="function"&&typeof u[u.length-2]!="function")throw new v(`Graph.${c}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let d,l;u.length===2?(d=u[0],l=u[1],u=[]):u.length===3?(d=u[1],l=u[2],u=[u[0]]):u.length===4&&(d=u[2],l=u[3],u=[u[0],u[1]]);let h=l;return u.push((f,m,x,b,A,S,N)=>{h=d(h,f,m,x,b,A,S,N)}),this[s].apply(this,u),h}}function ks(i,e){const{name:t,type:n,direction:r}=e,s="find"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(c,u,d){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return!1;if(arguments.length===1)return d=c,li(!0,this,n,d);if(arguments.length===2){c=""+c,d=u;const l=this._nodes.get(c);if(typeof l>"u")throw new w(`Graph.${s}: could not find the "${c}" node in the graph.`);return Jt(!0,this.multi,n==="mixed"?this.type:n,r,l,d)}if(arguments.length===3){c=""+c,u=""+u;const l=this._nodes.get(c);if(!l)throw new w(`Graph.${s}:  could not find the "${c}" source node in the graph.`);if(!this._nodes.has(u))throw new w(`Graph.${s}:  could not find the "${u}" target node in the graph.`);return Yt(!0,n,this.multi,r,l,u,d)}throw new v(`Graph.${s}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const o="some"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[o]=function(){const c=Array.prototype.slice.call(arguments),u=c.pop();return c.push((l,h,f,m,x,b,A)=>u(l,h,f,m,x,b,A)),!!this[s].apply(this,c)};const a="every"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[a]=function(){const c=Array.prototype.slice.call(arguments),u=c.pop();return c.push((l,h,f,m,x,b,A)=>!u(l,h,f,m,x,b,A)),!this[s].apply(this,c)}}function Ss(i,e){const{name:t,type:n,direction:r}=e,s=t.slice(0,-1)+"Entries";i.prototype[s]=function(o,a){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return je();if(!arguments.length)return ws(this,n);if(arguments.length===1){o=""+o;const c=this._nodes.get(o);if(!c)throw new w(`Graph.${s}: could not find the "${o}" node in the graph.`);return Es(n,r,c)}if(arguments.length===2){o=""+o,a=""+a;const c=this._nodes.get(o);if(!c)throw new w(`Graph.${s}:  could not find the "${o}" source node in the graph.`);if(!this._nodes.has(a))throw new w(`Graph.${s}:  could not find the "${a}" target node in the graph.`);return $s(n,r,c,a)}throw new v(`Graph.${s}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Ds(i){hs.forEach(e=>{xs(i,e),_s(i,e),ks(i,e),Ss(i,e)})}const Gs=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function kt(){this.A=null,this.B=null}kt.prototype.wrap=function(i){this.A===null?this.A=i:this.B===null&&(this.B=i)};kt.prototype.has=function(i){return this.A!==null&&i in this.A||this.B!==null&&i in this.B};function Fe(i,e,t,n,r){for(const s in n){const o=n[s],a=o.source,c=o.target,u=a===t?c:a;if(e&&e.has(u.key))continue;const d=r(u.key,u.attributes);if(i&&d)return u.key}}function Qt(i,e,t,n,r){if(e!=="mixed"){if(e==="undirected")return Fe(i,null,n,n.undirected,r);if(typeof t=="string")return Fe(i,null,n,n[t],r)}const s=new kt;let o;if(e!=="undirected"){if(t!=="out"){if(o=Fe(i,null,n,n.in,r),i&&o)return o;s.wrap(n.in)}if(t!=="in"){if(o=Fe(i,s,n,n.out,r),i&&o)return o;s.wrap(n.out)}}if(e!=="directed"&&(o=Fe(i,s,n,n.undirected,r),i&&o))return o}function Cs(i,e,t){if(i!=="mixed"){if(i==="undirected")return Object.keys(t.undirected);if(typeof e=="string")return Object.keys(t[e])}const n=[];return Qt(!1,i,e,t,function(r){n.push(r)}),n}function Ke(i,e,t){const n=Object.keys(t),r=n.length;let s=0;return{[Symbol.iterator](){return this},next(){let o=null;do{if(s>=r)return i&&i.wrap(t),{done:!0};const a=t[n[s++]],c=a.source,u=a.target;if(o=c===e?u:c,i&&i.has(o.key)){o=null;continue}}while(o===null);return{done:!1,value:{neighbor:o.key,attributes:o.attributes}}}}}function As(i,e,t){if(i!=="mixed"){if(i==="undirected")return Ke(null,t,t.undirected);if(typeof e=="string")return Ke(null,t,t[e])}let n=je();const r=new kt;return i!=="undirected"&&(e!=="out"&&(n=we(n,Ke(r,t,t.in))),e!=="in"&&(n=we(n,Ke(r,t,t.out)))),i!=="directed"&&(n=we(n,Ke(r,t,t.undirected))),n}function Is(i,e){const{name:t,type:n,direction:r}=e;i.prototype[t]=function(s){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return[];s=""+s;const o=this._nodes.get(s);if(typeof o>"u")throw new w(`Graph.${t}: could not find the "${s}" node in the graph.`);return Cs(n==="mixed"?this.type:n,r,o)}}function Ns(i,e){const{name:t,type:n,direction:r}=e,s="forEach"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(u,d){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return;u=""+u;const l=this._nodes.get(u);if(typeof l>"u")throw new w(`Graph.${s}: could not find the "${u}" node in the graph.`);Qt(!1,n==="mixed"?this.type:n,r,l,d)};const o="map"+t[0].toUpperCase()+t.slice(1);i.prototype[o]=function(u,d){const l=[];return this[s](u,(h,f)=>{l.push(d(h,f))}),l};const a="filter"+t[0].toUpperCase()+t.slice(1);i.prototype[a]=function(u,d){const l=[];return this[s](u,(h,f)=>{d(h,f)&&l.push(h)}),l};const c="reduce"+t[0].toUpperCase()+t.slice(1);i.prototype[c]=function(u,d,l){if(arguments.length<3)throw new v(`Graph.${c}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let h=l;return this[s](u,(f,m)=>{h=d(h,f,m)}),h}}function Rs(i,e){const{name:t,type:n,direction:r}=e,s=t[0].toUpperCase()+t.slice(1,-1),o="find"+s;i.prototype[o]=function(u,d){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return;u=""+u;const l=this._nodes.get(u);if(typeof l>"u")throw new w(`Graph.${o}: could not find the "${u}" node in the graph.`);return Qt(!0,n==="mixed"?this.type:n,r,l,d)};const a="some"+s;i.prototype[a]=function(u,d){return!!this[o](u,d)};const c="every"+s;i.prototype[c]=function(u,d){return!this[o](u,(h,f)=>!d(h,f))}}function Ms(i,e){const{name:t,type:n,direction:r}=e,s=t.slice(0,-1)+"Entries";i.prototype[s]=function(o){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return je();o=""+o;const a=this._nodes.get(o);if(typeof a>"u")throw new w(`Graph.${s}: could not find the "${o}" node in the graph.`);return As(n==="mixed"?this.type:n,r,a)}}function Os(i){Gs.forEach(e=>{Is(i,e),Ns(i,e),Rs(i,e),Ms(i,e)})}function ut(i,e,t,n,r){const s=n._nodes.values(),o=n.type;let a,c,u,d,l,h;for(;a=s.next(),a.done!==!0;){let f=!1;if(c=a.value,o!=="undirected"){d=c.out;for(u in d){l=d[u];do h=l.target,f=!0,r(c.key,h.key,c.attributes,h.attributes,l.key,l.attributes,l.undirected),l=l.next;while(l)}}if(o!=="directed"){d=c.undirected;for(u in d)if(!(e&&c.key>u)){l=d[u];do h=l.target,h.key!==u&&(h=l.source),f=!0,r(c.key,h.key,c.attributes,h.attributes,l.key,l.attributes,l.undirected),l=l.next;while(l)}}t&&!f&&r(c.key,null,c.attributes,null,null,null,null)}}function Ls(i,e){const t={key:i};return ri(e.attributes)||(t.attributes=U({},e.attributes)),t}function Ws(i,e,t){const n={key:e,source:t.source.key,target:t.target.key};return ri(t.attributes)||(n.attributes=U({},t.attributes)),i==="mixed"&&t.undirected&&(n.undirected=!0),n}function Ts(i){if(!B(i))throw new v('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in i))throw new v("Graph.import: serialized node is missing its key.");if("attributes"in i&&(!B(i.attributes)||i.attributes===null))throw new v("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function js(i){if(!B(i))throw new v('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in i))throw new v("Graph.import: serialized edge is missing its source.");if(!("target"in i))throw new v("Graph.import: serialized edge is missing its target.");if("attributes"in i&&(!B(i.attributes)||i.attributes===null))throw new v("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in i&&typeof i.undirected!="boolean")throw new v("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const Ps=Ur(),zs=new Set(["directed","undirected","mixed"]),vn=new Set(["domain","_events","_eventsCount","_maxListeners"]),Us=[{name:i=>`${i}Edge`,generateKey:!0},{name:i=>`${i}DirectedEdge`,generateKey:!0,type:"directed"},{name:i=>`${i}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:i=>`${i}EdgeWithKey`},{name:i=>`${i}DirectedEdgeWithKey`,type:"directed"},{name:i=>`${i}UndirectedEdgeWithKey`,type:"undirected"}],Fs={allowSelfLoops:!0,multi:!1,type:"mixed"};function Ks(i,e,t){if(t&&!B(t))throw new v(`Graph.addNode: invalid attributes. Expecting an object but got "${t}"`);if(e=""+e,t=t||{},i._nodes.has(e))throw new k(`Graph.addNode: the "${e}" node already exist in the graph.`);const n=new i.NodeDataClass(e,t);return i._nodes.set(e,n),i.emit("nodeAdded",{key:e,attributes:t}),n}function $n(i,e,t){const n=new i.NodeDataClass(e,t);return i._nodes.set(e,n),i.emit("nodeAdded",{key:e,attributes:t}),n}function hi(i,e,t,n,r,s,o,a){if(!n&&i.type==="undirected")throw new k(`Graph.${e}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(n&&i.type==="directed")throw new k(`Graph.${e}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!B(a))throw new v(`Graph.${e}: invalid attributes. Expecting an object but got "${a}"`);if(s=""+s,o=""+o,a=a||{},!i.allowSelfLoops&&s===o)throw new k(`Graph.${e}: source & target are the same ("${s}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const c=i._nodes.get(s),u=i._nodes.get(o);if(!c)throw new w(`Graph.${e}: source node "${s}" not found.`);if(!u)throw new w(`Graph.${e}: target node "${o}" not found.`);const d={key:null,undirected:n,source:s,target:o,attributes:a};if(t)r=i._edgeKeyGenerator();else if(r=""+r,i._edges.has(r))throw new k(`Graph.${e}: the "${r}" edge already exists in the graph.`);if(!i.multi&&(n?typeof c.undirected[o]<"u":typeof c.out[o]<"u"))throw new k(`Graph.${e}: an edge linking "${s}" to "${o}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const l=new Pe(n,r,c,u,a);i._edges.set(r,l);const h=s===o;return n?(c.undirectedDegree++,u.undirectedDegree++,h&&(c.undirectedLoops++,i._undirectedSelfLoopCount++)):(c.outDegree++,u.inDegree++,h&&(c.directedLoops++,i._directedSelfLoopCount++)),i.multi?l.attachMulti():l.attach(),n?i._undirectedSize++:i._directedSize++,d.key=r,i.emit("edgeAdded",d),r}function qs(i,e,t,n,r,s,o,a,c){if(!n&&i.type==="undirected")throw new k(`Graph.${e}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(n&&i.type==="directed")throw new k(`Graph.${e}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(a){if(c){if(typeof a!="function")throw new v(`Graph.${e}: invalid updater function. Expecting a function but got "${a}"`)}else if(!B(a))throw new v(`Graph.${e}: invalid attributes. Expecting an object but got "${a}"`)}s=""+s,o=""+o;let u;if(c&&(u=a,a=void 0),!i.allowSelfLoops&&s===o)throw new k(`Graph.${e}: source & target are the same ("${s}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let d=i._nodes.get(s),l=i._nodes.get(o),h,f;if(!t&&(h=i._edges.get(r),h)){if((h.source.key!==s||h.target.key!==o)&&(!n||h.source.key!==o||h.target.key!==s))throw new k(`Graph.${e}: inconsistency detected when attempting to merge the "${r}" edge with "${s}" source & "${o}" target vs. ("${h.source.key}", "${h.target.key}").`);f=h}if(!f&&!i.multi&&d&&(f=n?d.undirected[o]:d.out[o]),f){const S=[f.key,!1,!1,!1];if(c?!u:!a)return S;if(c){const N=f.attributes;f.attributes=u(N),i.emit("edgeAttributesUpdated",{type:"replace",key:f.key,attributes:f.attributes})}else U(f.attributes,a),i.emit("edgeAttributesUpdated",{type:"merge",key:f.key,attributes:f.attributes,data:a});return S}a=a||{},c&&u&&(a=u(a));const m={key:null,undirected:n,source:s,target:o,attributes:a};if(t)r=i._edgeKeyGenerator();else if(r=""+r,i._edges.has(r))throw new k(`Graph.${e}: the "${r}" edge already exists in the graph.`);let x=!1,b=!1;d||(d=$n(i,s,{}),x=!0,s===o&&(l=d,b=!0)),l||(l=$n(i,o,{}),b=!0),h=new Pe(n,r,d,l,a),i._edges.set(r,h);const A=s===o;return n?(d.undirectedDegree++,l.undirectedDegree++,A&&(d.undirectedLoops++,i._undirectedSelfLoopCount++)):(d.outDegree++,l.inDegree++,A&&(d.directedLoops++,i._directedSelfLoopCount++)),i.multi?h.attachMulti():h.attach(),n?i._undirectedSize++:i._directedSize++,m.key=r,i.emit("edgeAdded",m),[r,!0,x,b]}function Ae(i,e){i._edges.delete(e.key);const{source:t,target:n,attributes:r}=e,s=e.undirected,o=t===n;s?(t.undirectedDegree--,n.undirectedDegree--,o&&(t.undirectedLoops--,i._undirectedSelfLoopCount--)):(t.outDegree--,n.inDegree--,o&&(t.directedLoops--,i._directedSelfLoopCount--)),i.multi?e.detachMulti():e.detach(),s?i._undirectedSize--:i._directedSize--,i.emit("edgeDropped",{key:e.key,attributes:r,source:t.key,target:n.key,undirected:s})}class O extends Pr.EventEmitter{constructor(e){if(super(),e=U({},Fs,e),typeof e.multi!="boolean")throw new v(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!zs.has(e.type))throw new v(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if(typeof e.allowSelfLoops!="boolean")throw new v(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);const t=e.type==="mixed"?si:e.type==="directed"?oi:ai;ne(this,"NodeDataClass",t);const n="geid_"+Ps()+"_";let r=0;const s=()=>{let o;do o=n+r++;while(this._edges.has(o));return o};ne(this,"_attributes",{}),ne(this,"_nodes",new Map),ne(this,"_edges",new Map),ne(this,"_directedSize",0),ne(this,"_undirectedSize",0),ne(this,"_directedSelfLoopCount",0),ne(this,"_undirectedSelfLoopCount",0),ne(this,"_edgeKeyGenerator",s),ne(this,"_options",e),vn.forEach(o=>ne(this,o,this[o])),he(this,"order",()=>this._nodes.size),he(this,"size",()=>this._edges.size),he(this,"directedSize",()=>this._directedSize),he(this,"undirectedSize",()=>this._undirectedSize),he(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),he(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),he(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),he(this,"multi",this._options.multi),he(this,"type",this._options.type),he(this,"allowSelfLoops",this._options.allowSelfLoops),he(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if(this.type==="undirected")return!1;if(arguments.length===1){const n=""+e,r=this._edges.get(n);return!!r&&!r.undirected}else if(arguments.length===2){e=""+e,t=""+t;const n=this._nodes.get(e);return n?n.out.hasOwnProperty(t):!1}throw new v(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if(this.type==="directed")return!1;if(arguments.length===1){const n=""+e,r=this._edges.get(n);return!!r&&r.undirected}else if(arguments.length===2){e=""+e,t=""+t;const n=this._nodes.get(e);return n?n.undirected.hasOwnProperty(t):!1}throw new v(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(arguments.length===1){const n=""+e;return this._edges.has(n)}else if(arguments.length===2){e=""+e,t=""+t;const n=this._nodes.get(e);return n?typeof n.out<"u"&&n.out.hasOwnProperty(t)||typeof n.undirected<"u"&&n.undirected.hasOwnProperty(t):!1}throw new v(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if(this.type==="undirected")return;if(e=""+e,t=""+t,this.multi)throw new k("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const n=this._nodes.get(e);if(!n)throw new w(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new w(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);const r=n.out&&n.out[t]||void 0;if(r)return r.key}undirectedEdge(e,t){if(this.type==="directed")return;if(e=""+e,t=""+t,this.multi)throw new k("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const n=this._nodes.get(e);if(!n)throw new w(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new w(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);const r=n.undirected&&n.undirected[t]||void 0;if(r)return r.key}edge(e,t){if(this.multi)throw new k("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new w(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new w(`Graph.edge: could not find the "${t}" target node in the graph.`);const r=n.out&&n.out[t]||n.undirected&&n.undirected[t]||void 0;if(r)return r.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new w(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in n.in||t in n.out}areOutNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new w(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in n.out}areInNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new w(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in n.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new w(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="directed"?!1:t in n.undirected}areNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new w(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&(t in n.in||t in n.out)||this.type!=="directed"&&t in n.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new w(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in n.in||this.type!=="directed"&&t in n.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new w(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in n.out||this.type!=="directed"&&t in n.undirected}inDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.inDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree}outDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.outDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.outDegree}directedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return this.type==="directed"?0:t.undirectedDegree}inboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let n=0;return this.type!=="directed"&&(n+=t.undirectedDegree),this.type!=="undirected"&&(n+=t.inDegree),n}outboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let n=0;return this.type!=="directed"&&(n+=t.undirectedDegree),this.type!=="undirected"&&(n+=t.outDegree),n}degree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.degree: could not find the "${e}" node in the graph.`);let n=0;return this.type!=="directed"&&(n+=t.undirectedDegree),this.type!=="undirected"&&(n+=t.inDegree+t.outDegree),n}inDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree+t.outDegree-t.directedLoops*2}undirectedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="directed"?0:t.undirectedDegree-t.undirectedLoops*2}inboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let n=0,r=0;return this.type!=="directed"&&(n+=t.undirectedDegree,r+=t.undirectedLoops*2),this.type!=="undirected"&&(n+=t.inDegree,r+=t.directedLoops),n-r}outboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let n=0,r=0;return this.type!=="directed"&&(n+=t.undirectedDegree,r+=t.undirectedLoops*2),this.type!=="undirected"&&(n+=t.outDegree,r+=t.directedLoops),n-r}degreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let n=0,r=0;return this.type!=="directed"&&(n+=t.undirectedDegree,r+=t.undirectedLoops*2),this.type!=="undirected"&&(n+=t.inDegree+t.outDegree,r+=t.directedLoops*2),n-r}source(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;const n=this._edges.get(t);if(!n)throw new w(`Graph.opposite: could not find the "${t}" edge in the graph.`);const r=n.source.key,s=n.target.key;if(e===r)return s;if(e===s)return r;throw new w(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${r}, ${s}).`)}hasExtremity(e,t){e=""+e,t=""+t;const n=this._edges.get(e);if(!n)throw new w(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return n.source.key===t||n.target.key===t}isUndirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return Ks(this,e,t).key}mergeNode(e,t){if(t&&!B(t))throw new v(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let n=this._nodes.get(e);return n?(t&&(U(n.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:n.attributes,data:t})),[e,!1]):(n=new this.NodeDataClass(e,t),this._nodes.set(e,n),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&typeof t!="function")throw new v(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let n=this._nodes.get(e);if(n){if(t){const s=n.attributes;n.attributes=t(s),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:n.attributes})}return[e,!1]}const r=t?t({}):{};return n=new this.NodeDataClass(e,r),this._nodes.set(e,n),this.emit("nodeAdded",{key:e,attributes:r}),[e,!0]}dropNode(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.dropNode: could not find the "${e}" node in the graph.`);let n;if(this.type!=="undirected"){for(const r in t.out){n=t.out[r];do Ae(this,n),n=n.next;while(n)}for(const r in t.in){n=t.in[r];do Ae(this,n),n=n.next;while(n)}}if(this.type!=="directed")for(const r in t.undirected){n=t.undirected[r];do Ae(this,n),n=n.next;while(n)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:t.attributes})}dropEdge(e){let t;if(arguments.length>1){const n=""+arguments[0],r=""+arguments[1];if(t=ae(this,n,r,this.type),!t)throw new w(`Graph.dropEdge: could not find the "${n}" -> "${r}" edge in the graph.`)}else if(e=""+e,t=this._edges.get(e),!t)throw new w(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return Ae(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new k("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new k("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");e=""+e,t=""+t;const n=ae(this,e,t,"directed");if(!n)throw new w(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return Ae(this,n),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new k("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new k("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const n=ae(this,e,t,"undirected");if(!n)throw new w(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return Ae(this,n),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const e=this._nodes.values();let t;for(;t=e.next(),t.done!==!0;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if(typeof t!="function")throw new v("Graph.updateAttribute: updater should be a function.");const n=this._attributes[e];return this._attributes[e]=t(n),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!B(e))throw new v("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!B(e))throw new v("Graph.mergeAttributes: provided attributes are not a plain object.");return U(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if(typeof e!="function")throw new v("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){if(typeof e!="function")throw new v("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!En(t))throw new v("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const n=this._nodes.values();let r,s;for(;r=n.next(),r.done!==!0;)s=r.value,s.attributes=e(s.key,s.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){if(typeof e!="function")throw new v("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!En(t))throw new v("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const n=this._edges.values();let r,s,o,a;for(;r=n.next(),r.done!==!0;)s=r.value,o=s.source,a=s.target,s.attributes=e(s.key,s.attributes,o.key,a.key,o.attributes,a.attributes,s.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if(typeof e!="function")throw new v("Graph.forEachAdjacencyEntry: expecting a callback.");ut(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new v("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");ut(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if(typeof e!="function")throw new v("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");ut(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new v("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");ut(!1,!0,!0,this,e)}nodes(){return Array.from(this._nodes.keys())}forEachNode(e){if(typeof e!="function")throw new v("Graph.forEachNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),n.done!==!0;)r=n.value,e(r.key,r.attributes)}findNode(e){if(typeof e!="function")throw new v("Graph.findNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),n.done!==!0;)if(r=n.value,e(r.key,r.attributes))return r.key}mapNodes(e){if(typeof e!="function")throw new v("Graph.mapNode: expecting a callback.");const t=this._nodes.values();let n,r;const s=new Array(this.order);let o=0;for(;n=t.next(),n.done!==!0;)r=n.value,s[o++]=e(r.key,r.attributes);return s}someNode(e){if(typeof e!="function")throw new v("Graph.someNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),n.done!==!0;)if(r=n.value,e(r.key,r.attributes))return!0;return!1}everyNode(e){if(typeof e!="function")throw new v("Graph.everyNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),n.done!==!0;)if(r=n.value,!e(r.key,r.attributes))return!1;return!0}filterNodes(e){if(typeof e!="function")throw new v("Graph.filterNodes: expecting a callback.");const t=this._nodes.values();let n,r;const s=[];for(;n=t.next(),n.done!==!0;)r=n.value,e(r.key,r.attributes)&&s.push(r.key);return s}reduceNodes(e,t){if(typeof e!="function")throw new v("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new v("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let n=t;const r=this._nodes.values();let s,o;for(;s=r.next(),s.done!==!0;)o=s.value,n=e(n,o.key,o.attributes);return n}nodeEntries(){const e=this._nodes.values();return{[Symbol.iterator](){return this},next(){const t=e.next();if(t.done)return t;const n=t.value;return{value:{node:n.key,attributes:n.attributes},done:!1}}}}export(){const e=new Array(this._nodes.size);let t=0;this._nodes.forEach((r,s)=>{e[t++]=Ls(s,r)});const n=new Array(this._edges.size);return t=0,this._edges.forEach((r,s)=>{n[t++]=Ws(this.type,s,r)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:n}}import(e,t=!1){if(e instanceof O)return e.forEachNode((c,u)=>{t?this.mergeNode(c,u):this.addNode(c,u)}),e.forEachEdge((c,u,d,l,h,f,m)=>{t?m?this.mergeUndirectedEdgeWithKey(c,d,l,u):this.mergeDirectedEdgeWithKey(c,d,l,u):m?this.addUndirectedEdgeWithKey(c,d,l,u):this.addDirectedEdgeWithKey(c,d,l,u)}),this;if(!B(e))throw new v("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!B(e.attributes))throw new v("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}let n,r,s,o,a;if(e.nodes){if(s=e.nodes,!Array.isArray(s))throw new v("Graph.import: invalid nodes. Expecting an array.");for(n=0,r=s.length;n<r;n++){o=s[n],Ts(o);const{key:c,attributes:u}=o;t?this.mergeNode(c,u):this.addNode(c,u)}}if(e.edges){let c=!1;if(this.type==="undirected"&&(c=!0),s=e.edges,!Array.isArray(s))throw new v("Graph.import: invalid edges. Expecting an array.");for(n=0,r=s.length;n<r;n++){a=s[n],js(a);const{source:u,target:d,attributes:l,undirected:h=c}=a;let f;"key"in a?(f=t?h?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:h?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,f.call(this,a.key,u,d,l)):(f=t?h?this.mergeUndirectedEdge:this.mergeDirectedEdge:h?this.addUndirectedEdge:this.addDirectedEdge,f.call(this,u,d,l))}}return this}nullCopy(e){const t=new O(U({},this._options,e));return t.replaceAttributes(U({},this.getAttributes())),t}emptyCopy(e){const t=this.nullCopy(e);return this._nodes.forEach((n,r)=>{const s=U({},n.attributes);n=new t.NodeDataClass(r,s),t._nodes.set(r,n)}),t}copy(e){if(e=e||{},typeof e.type=="string"&&e.type!==this.type&&e.type!=="mixed")throw new k(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if(typeof e.multi=="boolean"&&e.multi!==this.multi&&e.multi!==!0)throw new k("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof e.allowSelfLoops=="boolean"&&e.allowSelfLoops!==this.allowSelfLoops&&e.allowSelfLoops!==!0)throw new k("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const t=this.emptyCopy(e),n=this._edges.values();let r,s;for(;r=n.next(),r.done!==!0;)s=r.value,hi(t,"copy",!1,s.undirected,s.key,s.source.key,s.target.key,U({},s.attributes));return t}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const e={};this._nodes.forEach((s,o)=>{e[o]=s.attributes});const t={},n={};this._edges.forEach((s,o)=>{const a=s.undirected?"--":"->";let c="",u=s.source.key,d=s.target.key,l;s.undirected&&u>d&&(l=u,u=d,d=l);const h=`(${u})${a}(${d})`;o.startsWith("geid_")?this.multi&&(typeof n[h]>"u"?n[h]=0:n[h]++,c+=`${n[h]}. `):c+=`[${o}]: `,c+=h,t[c]=s.attributes});const r={};for(const s in this)this.hasOwnProperty(s)&&!vn.has(s)&&typeof this[s]!="function"&&typeof s!="symbol"&&(r[s]=this[s]);return r.attributes=this._attributes,r.nodes=e,r.edges=t,ne(r,"constructor",this.constructor),r}}typeof Symbol<"u"&&(O.prototype[Symbol.for("nodejs.util.inspect.custom")]=O.prototype.inspect);Us.forEach(i=>{["add","merge","update"].forEach(e=>{const t=i.name(e),n=e==="add"?hi:qs;i.generateKey?O.prototype[t]=function(r,s,o){return n(this,t,!0,(i.type||this.type)==="undirected",null,r,s,o,e==="update")}:O.prototype[t]=function(r,s,o,a){return n(this,t,!1,(i.type||this.type)==="undirected",r,s,o,a,e==="update")}})});es(O);ls(O);Ds(O);Os(O);class fi extends O{constructor(e){const t=U({type:"directed"},e);if("multi"in t&&t.multi!==!1)throw new v("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="directed")throw new v('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class pi extends O{constructor(e){const t=U({type:"undirected"},e);if("multi"in t&&t.multi!==!1)throw new v("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="undirected")throw new v('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class gi extends O{constructor(e){const t=U({multi:!0},e);if("multi"in t&&t.multi!==!0)throw new v("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class mi extends O{constructor(e){const t=U({type:"directed",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new v("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="directed")throw new v('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class yi extends O{constructor(e){const t=U({type:"undirected",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new v("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="undirected")throw new v('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function ze(i){i.from=function(e,t){const n=U({},e.options,t),r=new i(n);return r.import(e),r}}ze(O);ze(fi);ze(pi);ze(gi);ze(mi);ze(yi);O.Graph=O;O.DirectedGraph=fi;O.UndirectedGraph=pi;O.MultiGraph=gi;O.MultiDirectedGraph=mi;O.MultiUndirectedGraph=yi;O.InvalidArgumentsGraphError=v;O.NotFoundGraphError=w;O.UsageGraphError=k;function dt(i){return()=>i}function Xt(...i){return le(Bs,i)}function Bs(i,e){for(let[t,n]of i.entries())if(!e(n,t,i))return i.slice(t);return[]}const Vs=i=>Object.assign(i,{single:!0});function Zt(...i){return le(Hs,i)}const Hs=(i,e)=>{for(let t=i.length-1;t>=0;t--){let n=i[t];if(e(n,t,i))return n}};function Js(...i){return le(Ys,i,Vs(Qs))}const Ys=([i])=>i,Qs=()=>Xs,Xs=i=>({hasNext:!0,next:i,done:!0});function X(...i){return le(Zs,i,eo)}function Zs(i,e){return i.forEach(e),i}const eo=i=>(e,t,n)=>(i(e,t,n),{done:!1,hasNext:!0,next:e});function to(i){return typeof i=="boolean"}function xn(...i){return le(no,i)}function no(i,e){let t={};for(let[n,r]of i.entries()){let[s,o]=e(r,n,i);t[s]=o}return t}function wi(...i){return le(io,i)}function io(i,e){if(!ce(e,1))return{...i};if(!ce(e,2)){let{[e[0]]:n,...r}=i;return r}let t={...i};for(let n of e)delete t[n];return t}function z(...i){return le(ro,i)}const ro=i=>i.length===1?i[0]:void 0;function vt(...i){return le(so,i)}const so=(i,e)=>{let t=[[],[]];for(let[n,r]of i.entries())e(r,n,i)?t[0].push(r):t[1].push(r);return t};function oo(...i){return le(ao,i)}function ao(i,e){let t={};for(let[n,r]of Object.entries(i))e(r,n,i)&&(t[n]=r);return t}function rt(...i){return le(co,i)}const co=(i,e,t)=>i.reduce(e,t);function _n(...i){return le(uo,i)}function uo(i){return[...i].reverse()}function bi(...i){return le(lo,i,ho)}const lo=(i,e)=>e<0?[]:i.slice(0,e);function ho(i){if(i<=0)return Rr;let e=i;return t=>(--e,{done:e<=0,hasNext:!0,next:t})}function lt(...i){return i.length===2?(e,...t)=>kn(e,...i,...t):kn(...i)}const kn=(i,e,t,...n)=>e(i,...n)?typeof t=="function"?t(i,...n):t.onTrue(i,...n):typeof t=="function"?i:t.onFalse(i,...n);function Tt(i,e){const t=[];let n=i.parent;for(;n;){const r=re(e.get(n),`Parent node ${n} not found`);t.push(r),n=r.parent}return t}function Ei(i,e){for(const t of e){const n=i.get(t.source),r=i.get(t.target);L(n,`Source node ${t.source} not found`),L(r,`Target node ${t.target} not found`),n.outEdges.push(t.id),r.inEdges.push(t.id);const s=Tt(n,i),o=Tt(r,i),c=s.length>0&&o.length>0?er(tr(_n(s),_n(o))):null;t.parent=c?c.id:null;for(const u of s){if(u===c)break;u.outEdges.push(t.id)}for(const u of o){if(u===c)break;u.inEdges.push(t.id)}}}var Ie={},Ct,Sn;function vi(){return Sn||(Sn=1,Ct=function(e){return e!==null&&typeof e=="object"&&typeof e.addUndirectedEdgeWithKey=="function"&&typeof e.dropNode=="function"&&typeof e.multi=="boolean"}),Ct}var At,Dn;function fo(){if(Dn)return At;Dn=1;var i=_r(),e=xr();function t(n,r){if(arguments.length<2)throw new Error("mnemonist/fixed-deque: expecting an Array class and a capacity.");if(typeof r!="number"||r<=0)throw new Error("mnemonist/fixed-deque: `capacity` should be a positive number.");this.ArrayClass=n,this.capacity=r,this.items=new n(this.capacity),this.clear()}return t.prototype.clear=function(){this.start=0,this.size=0},t.prototype.push=function(n){if(this.size===this.capacity)throw new Error("mnemonist/fixed-deque.push: deque capacity ("+this.capacity+") exceeded!");var r=this.start+this.size;return r>=this.capacity&&(r-=this.capacity),this.items[r]=n,++this.size},t.prototype.unshift=function(n){if(this.size===this.capacity)throw new Error("mnemonist/fixed-deque.unshift: deque capacity ("+this.capacity+") exceeded!");var r=this.start-1;return this.start===0&&(r=this.capacity-1),this.items[r]=n,this.start=r,++this.size},t.prototype.pop=function(){if(this.size!==0){this.size--;var n=this.start+this.size;return n>=this.capacity&&(n-=this.capacity),this.items[n]}},t.prototype.shift=function(){if(this.size!==0){var n=this.start;return this.size--,this.start++,this.start===this.capacity&&(this.start=0),this.items[n]}},t.prototype.peekFirst=function(){if(this.size!==0)return this.items[this.start]},t.prototype.peekLast=function(){if(this.size!==0){var n=this.start+this.size-1;return n>=this.capacity&&(n-=this.capacity),this.items[n]}},t.prototype.get=function(n){if(!(this.size===0||n>=this.capacity))return n=this.start+n,n>=this.capacity&&(n-=this.capacity),this.items[n]},t.prototype.forEach=function(n,r){r=arguments.length>1?r:this;for(var s=this.capacity,o=this.size,a=this.start,c=0;c<o;)n.call(r,this.items[a],c,this),a++,c++,a===s&&(a=0)},t.prototype.toArray=function(){var n=this.start+this.size;if(n<this.capacity)return this.items.slice(this.start,n);for(var r=new this.ArrayClass(this.size),s=this.capacity,o=this.size,a=this.start,c=0;c<o;)r[c]=this.items[a],a++,c++,a===s&&(a=0);return r},t.prototype.values=function(){var n=this.items,r=this.capacity,s=this.size,o=this.start,a=0;return new e(function(){if(a>=s)return{done:!0};var c=n[o];return o++,a++,o===r&&(o=0),{value:c,done:!1}})},t.prototype.entries=function(){var n=this.items,r=this.capacity,s=this.size,o=this.start,a=0;return new e(function(){if(a>=s)return{done:!0};var c=n[o];return o++,o===r&&(o=0),{value:[a++,c],done:!1}})},typeof Symbol<"u"&&(t.prototype[Symbol.iterator]=t.prototype.values),t.prototype.inspect=function(){var n=this.toArray();return n.type=this.ArrayClass.name,n.capacity=this.capacity,Object.defineProperty(n,"constructor",{value:t,enumerable:!1}),n},typeof Symbol<"u"&&(t.prototype[Symbol.for("nodejs.util.inspect.custom")]=t.prototype.inspect),t.from=function(n,r,s){if(arguments.length<3&&(s=i.guessLength(n),typeof s!="number"))throw new Error("mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.");var o=new t(r,s);if(i.isArrayLike(n)){var a,c;for(a=0,c=n.length;a<c;a++)o.items[a]=n[a];return o.size=c,o}return i.forEach(n,function(u){o.push(u)}),o},At=t,At}var Gn;function po(){if(Gn)return Ie;Gn=1;const i=vi(),e=fo();function t(a,c){let u=0;return a.forEachInNeighbor(c,()=>{u++}),u}function n(a,c){if(!i(a))throw new Error("graphology-dag/topological-sort: the given graph is not a valid graphology instance.");if(a.type==="undirected"||a.undirectedSize!==0)throw new Error("graphology-dag/topological-sort: cannot work if graph is not directed.");if(a.order===0)return;const u=new e(Array,a.order),d={};let l=0;a.forEachNode((m,x)=>{const b=a.multi?t(a,m):a.inDegree(m);b===0?u.push([m,x,0]):(d[m]=b,l+=b)});let h=0;function f(m,x){const b=--d[m];l--,b===0&&u.push([m,x,h+1]),d[m]=b}for(;u.size!==0;){const[m,x,b]=u.shift();h=b,c(m,x,b),a.forEachOutNeighbor(m,f)}if(l!==0)throw new Error("graphology-dag/topological-sort: given graph is not acyclic.")}function r(a){if(!i(a))throw new Error("graphology-dag/topological-sort: the given graph is not a valid graphology instance.");const c=new Array(a.order);let u=0;return n(a,d=>{c[u++]=d}),c}function s(a,c){if(!i(a))throw new Error("graphology-dag/topological-generations: the given graph is not a valid graphology instance.");if(a.order===0)return;let u=0,d=[];n(a,(l,h,f)=>{f>u&&(c(d),u=f,d=[]),d.push(l)}),c(d)}function o(a){if(!i(a))throw new Error("graphology-dag/topological-generations: the given graph is not a valid graphology instance.");const c=[];return s(a,u=>{c.push(u)}),c}return Ie.topologicalSort=r,Ie.forEachNodeInTopologicalOrder=n,Ie.topologicalGenerations=o,Ie.forEachTopologicalGeneration=s,Ie}var go=po(),It,Cn;function mo(){if(Cn)return It;Cn=1;const i=vi();return It=function(t,n,r){if(!i(t))throw new Error("graphology-dag/will-create-cycle: the given graph is not a valid graphology instance.");if(n=""+n,r=""+r,n===r)return!0;if(!t.hasNode(n)||!t.hasNode(r)||t.hasDirectedEdge(n,r))return!1;if(t.hasDirectedEdge(r,n))return!0;const s=t.outNeighbors(r);function o(a){s.push(a)}for(;s.length!==0;){const a=s.pop();if(a===n)return!0;t.forEachOutNeighbor(a,o)}return!1},It}var yo=mo();const qe=ir(yo);function An(i){const e=[],t=[...i];let n;for(;n=t.shift();){let r=n.parent;if(r){const s=[];for(;r;){const o=t.findIndex(c=>c.id===r);if(o<0)break;const[a]=t.splice(o,1);if(!a)throw new Error("Invalid state, should not happen");s.unshift(a),r=a.parent}e.push(...s)}e.push(n)}return e}function wo(i){return i.forEach(e=>{e.children.length>0&&(e.children=i.reduce((t,n)=>(n.parent===e.id&&t.push(n.id),t),[]))}),i}function $i(i){let e=An([...i.nodes.values()]),t=[...i.edges];if(e.length<2||t.length===0)return{nodes:e,edges:t};const n=f=>re(i.nodes.get(f)),r=new O({multi:!0,allowSelfLoops:!0,type:"directed"}),s=$(t,F(f=>{const m=n(f.source),x=n(f.target),b=f.parent?n(f.parent):null;return{id:f.id,edge:f,parent:b,source:m,target:x}})),[o,a]=vt(s,({source:f,target:m})=>f.children.length===0&&m.children.length===0),c=[],u=f=>{r.mergeNode(f.source),r.mergeNode(f.target),c.push(f),qe(r,f.source,f.target)||r.mergeDirectedEdge(f.source,f.target)};for(const{edge:f,source:m,target:x}of o)if(u(f),x.parent&&x.parent!==f.parent&&$(Tt(x,i.nodes),nr(b=>b.inEdges.includes(f.id)),X(b=>{r.mergeNode(b.id),qe(r,f.source,b.id)||r.mergeDirectedEdge(f.source,b.id),qe(r,b.id,f.target)||r.mergeDirectedEdge(b.id,f.target)})),m.parent){const b=n(m.parent);r.mergeNode(b.id),qe(r,b.id,m.id)||r.mergeDirectedEdge(b.id,m.id),x.parent&&x.parent!==m.parent&&(qe(r,b.id,x.parent)||r.mergeDirectedEdge(b.id,x.parent))}for(const{edge:f}of a)u(f);L(c.length===t.length,"Not all edges were added to the graph");const d=go.topologicalSort(r);let l=[],h=e.slice();for(const f of d){const m=h.findIndex(x=>x.id===f);L(m>=0,`Node "${f}" not found`),l.push(...h.splice(m,1))}return h.length>0&&l.length>0&&(l=l.flatMap(f=>{if(h.length===0)return f;const m=e.slice(0,e.indexOf(f)).filter(x=>h.includes(x));return m.length>0?(h=h.filter(x=>!m.includes(x)),[...m,f]):f})),l.push(...h),{nodes:wo(An(l)),edges:c}}function en(i){const e={id:i.id,__:i._type??"element",autoLayout:i.autoLayout,nodes:$(i.nodes,F(t=>({id:t.id,icon:K(t.icon)&&t.icon!=="none"?"Y":"N",title:t.title,description:dn(t.description),technology:t.technology??null,shape:t.shape,size:t.style.size??null,textSize:t.style.textSize??null,padding:t.style.padding??null,children:t.children})),xn(({id:t,...n})=>[t,n])),edges:$(i.edges,F(t=>({source:t.source,target:t.target,label:t.label,description:dn(t.description),technology:t.technology??null,dir:t.dir,head:t.head,tail:t.tail,line:t.line})),xn(({source:t,target:n,...r})=>[`${t}:${n}`,r]))};return i.hash=rr(e),i}class xi{constructor(e){this.state=e}get Ctx(){throw new Error("Should not be called in runtime")}get elements(){return this.state.elements}get explicits(){return this.state.explicits}get final(){return this.state.final}get connections(){return this.state.connections}isEmpty(){return this.elements.size===0&&this.connections.length===0&&this.explicits.size===0&&this.final.size===0}}class _i{constructor(e,t){this.memory=e,this.expression=t}excluded={elements:new Set,connections:[]};markedToMoveExplicitToImplicit=!1;_removeElement(e){this.excluded.elements.add(e)}exclude(e){if(!e)return this;if(ke(e)){for(const t of e)this._removeElement(t);return this}return this._removeElement(e),this}_removeConnection(e){this.excluded.connections.push(e)}excludeConnections(e,t){if(to(t)&&(L(!this.markedToMoveExplicitToImplicit,"Already marked to move explicits"),this.markedToMoveExplicitToImplicit=t),ke(e)){for(const n of e)this._removeConnection(n);return this}return this._removeConnection(e),this}isDirty(){return this.excluded.elements.size>0||this.excluded.connections.length>0}isEmpty(){return!this.isDirty()}filterForMoveToImplicits(e){return this.markedToMoveExplicitToImplicit||this.excluded.elements.size>0?e:new Set}moveDisconnectedExplicitsToImplicits(e){let t=j(new Set(this.memory.connections.flatMap(n=>[n.source,n.target])),new Set(e.connections.flatMap(n=>[n.source,n.target])));return t=se(t,e.elements),t=$(t,J(n=>e.explicits.has(n)&&!Vt(e.final,Zn(n))),ge()),t.size>0&&(t=this.filterForMoveToImplicits(t),e.explicits=j(e.explicits,t),e.final=j(e.final,t)),e}removeElements(e){return e.elements=j(e.elements,this.excluded.elements),e.explicits=j(e.explicits,this.excluded.elements),e.final=j(e.final,this.excluded.elements),e}removeConnections(e){const t=this.excluded.connections.reduce((r,s)=>{const o=r.get(s.id);return o?r.set(s.id,o.mergeWith(s)):r.set(s.id,s),r},new Map);let n=new Set;e.connections=e.connections.reduce((r,s)=>{const o=t.get(s.id);if(o){n.add(s.source),n.add(s.target);const a=s.difference(o);a.nonEmpty()&&r.push(a)}else r.push(s);return r},[]);for(const r of e.connections)n.delete(r.source),n.delete(r.target),r.boundary&&e.elements.has(r.boundary)&&n.delete(r.boundary);return n.size===0||(n=j(n,e.explicits),e.final=j(e.final,n)),e}precommit(e){return e}postcommit(e){return L(j(e.explicits,e.elements).size===0,"Explicits must be subset of elements"),L(j(e.final,e.elements).size===0,"Final elements must be subset of elements"),e}commit(){let e=this.precommit(this.memory.mutableState());if(this.excluded.elements.size>0){const t=e.connections.filter(n=>this.excluded.elements.has(n.source)||this.excluded.elements.has(n.target)).flatMap(n=>[n,...yr(e.connections,n).map(r=>r.intersect(n))]).filter(n=>n.nonEmpty());this.excludeConnections(t)}return this.excluded.connections.length>0&&(e=this.removeConnections(e)),this.excluded.elements.size>0&&(e=this.removeElements(e)),this.memory.update(this.postcommit(e))}}class ki{constructor(e,t){this.memory=e,this.expression=t}explicits=new Set;implicits=new Set;_ordered=new Set;_connections=[];get elements(){return this.explicits}get connections(){return this._connections}mergedConnections(){return Ye([...this.memory.connections,...this._connections])}connectWithExisting(e,t){throw new Error("Method not implements, depends on the model")}_addExplicit(e){this._ordered.add(e),this.explicits.add(e),this.implicits.delete(e)}addExplicit(e){if(!e)return this;if(ke(e)){for(const t of e)this._addExplicit(t);return this}return this._addExplicit(e),this}_addImplicit(e){this.explicits.has(e)||(this._ordered.add(e),this.implicits.add(e))}addImplicit(e){if(!e)return this;if(ke(e)){for(const t of e)this._addImplicit(t);return this}return this._addImplicit(e),this}_addConnection(e){this._connections.push(e),this._addImplicit(e.source),this._addImplicit(e.target)}addConnections(e){if(ke(e)){for(const t of e)this._addConnection(t);return this}return this._addConnection(e),this}isDirty(){return this.explicits.size>0||this.implicits.size>0||this._connections.length>0}isEmpty(){return!this.isDirty()}precommit(e){return e}postcommit(e){return e}processConnections(e){return e}commit(){let e=this.precommit(this.memory.mutableState()),t=new Set;if(this._connections.length>0){const[n,r]=vt(this._connections,s=>e.final.has(s.source));e.connections=this.processConnections(Ye([...e.connections,...n,...r])),t=new Set(e.connections.flatMap(s=>[s.source,s.target]))}return e.elements=P(e.elements,this._ordered,this.explicits,t,this.implicits),e.explicits=se(e.elements,P(e.explicits,this.explicits)),e.final=se(e.elements,P(e.final,this.explicits,t)),this.memory.update(this.postcommit(e))}}function Si(i,e="final"){const t=mt(R(e==="final"?i.final:i.elements)),n=new Set(i.connections.flatMap(a=>[a.source,a.target])),r=new Set(t),s=new We(()=>null),o=t.reduce((a,c,u,d)=>(a.set(c,d.slice(u+1).filter(l=>$e(c,l)).map(l=>(r.delete(l),l)).reduce((l,h)=>(l.some(f=>$e(f,h))||(l.push(h),s.set(h,c)),l),[])),a),new We(()=>[]));return{root:r,connected:n,hasInOut:a=>i.connections.some(ee.isAnyInOut(a.id)),parent:a=>s.get(a),children:a=>o.get(a)}}let bo=class extends _i{};function te(i){if(C.isCustom(i))return te(i.custom.expr);if(C.isWhere(i)){const e=te(i.where.expr),t=xe(i.where.condition);return n=>e(n)&&t(n)}if(C.isElementKindExpr(i))return i.isEqual?e=>e.kind===i.elementKind:e=>e.kind!==i.elementKind;if(C.isElementTagExpr(i))return i.isEqual?({tags:e})=>e.includes(i.elementTag):({tags:e})=>!e.includes(i.elementTag);if(C.isWildcard(i))return()=>!0;if(C.isModelRef(i)){const e=Q.flatten(i.ref);if(i.selector==="expanded")return t=>t.id===e||Le(t.id)===e;if(i.selector==="descendants"||i.selector==="children"){const t=e+".";return n=>n.id.startsWith(t)}return t=>t.id===e}de(i)}function Di(i,e,t){const{shape:n,color:r,icon:s,...o}=i.style,a=!He(o);$(t,M(cr(Un)),M(e),X(c=>{c.shape=n??c.shape,c.color=r??c.color,hn(s)&&(c.icon=s),hn(i.notation)&&(c.notation=i.notation),a&&(c.style={...c.style,...o})}))}function Gi(i,e){for(const t of i){if(!Wn(t)||t.targets.length===0)continue;const n=t.targets.map(te);Di(t,oe(n),e)}return e}function Eo(i,e){let t;for(;i.parent&&(t=e.get(i.parent));){const n=t.depth??1;if(t.depth=Math.max(n,(i.depth??0)+1),t.depth===n)break;i=t}}function Ci(i){const{id:e,title:t,...n}=wi(i.$element,["summary","description","metadata","style","tags"]),{color:r,icon:s,shape:o,...a}=i.style;return ue({id:e,title:t,modelRef:e,shape:o,color:r,icon:s,style:a,description:wt(i.$element),tags:[...i.tags],...n})}function tn({defaults:i},e,t){const n=new Map,r=new Map;t?.forEach(({id:o,parent:a,viewRule:c,elements:u})=>{a&&re(n.get(a),`Parent group node ${a} not found`).children.push(o),n.set(o,{id:o,parent:a,kind:Kn,title:c.title??"",color:c.color??i.group?.color??i.color,shape:"rectangle",children:[],inEdges:[],outEdges:[],level:0,depth:0,tags:[],style:ue({border:c.border??i.group?.border??i.border,opacity:c.opacity??i.group?.opacity??i.opacity,size:c.size,multiple:c.multiple,padding:c.padding,textSize:c.textSize})});for(const d of u)r.set(d.id,o)}),Array.from(e).sort(or).forEach(({id:o,...a})=>{let c=Le(o),u=0,d;for(;c&&(d=n.get(c),!d);)c=Le(c);const l=a.modelRef??o;if(!d&&r.has(l)){const f=re(r.get(l));d=n.get(f),c=f}d&&(d.children.length==0&&(d.depth=1,Eo(d,n)),d.children.push(o),u=d.level+1);const h=ue({id:o,parent:c,level:u,children:[],inEdges:[],outEdges:[],...a});n.set(o,h)});const s=new Map;return t?.forEach(({id:o})=>{s.set(o,re(n.get(o)))}),e.forEach(({id:o})=>{s.set(o,re(n.get(o)))}),s}function vo(i){const{title:e,description:t=null}=i;return{...e&&{title:e,description:t},...yt(i,["color","technology","head","line","tail","kind","navigateTo"])}}function Ai(i,e){const t=$(i,rt((o,a)=>(K(a.title)&&!o.title.includes(a.title)&&o.title.push(a.title),K(a.description)&&!o.description.some(qn(a.description))&&o.description.push(a.description),K(a.technology)&&!o.technology.includes(a.technology)&&o.technology.push(a.technology),K(a.kind)&&!o.kind.includes(a.kind)&&o.kind.push(a.kind),K(a.color)&&!o.color.includes(a.color)&&o.color.push(a.color),K(a.line)&&!o.line.includes(a.line)&&o.line.push(a.line),K(a.head)&&!o.head.includes(a.head)&&o.head.push(a.head),K(a.tail)&&!o.tail.includes(a.tail)&&o.tail.push(a.tail),K(a.navigateTo)&&!o.navigateTo.includes(a.navigateTo)&&o.navigateTo.push(a.navigateTo),a.tags&&o.tags.push(...a.tags),o),{title:[],description:[],technology:[],kind:[],head:[],tail:[],color:[],tags:[],line:[],navigateTo:[]}));let n=z(t.title)??(t.title.length>1?"[...]":void 0);const r=Te(t.tags);let s=ue({title:n,description:z(t.description),technology:z(t.technology),kind:z(t.kind),head:z(t.head),tail:z(t.tail),color:z(t.color),line:z(t.line),navigateTo:z(t.navigateTo),...Vn(r)&&{tags:r}});if(e){const o=vo(e);s=oo({...s,...o},K)}return Se(s.title)&&K(s.technology)&&(s.title=`[${s.technology}]`,delete s.technology),s}const{findConnection:St,findConnectionsBetween:fe,findConnectionsWithin:st}=lr;function me(i,e){const t=i.element(e.ref.deployment);if(t.isDeploymentNode()){if(e.selector==="children")return[...t.children()];if(e.selector==="expanded")return[t,...t.children()];if(e.selector==="descendants")return[...t.descendants()]}return[t]}function Qe(i,e){const t=i.$model.element(e.ref.model);return e.selector==="children"?[...t.children()]:e.selector==="expanded"?[t,...t.children()]:e.selector==="descendants"?[...t.descendants()]:[t]}function $t(i){if(D.isWildcard(i))return()=>!0;if(D.isElementTagExpr(i)||D.isElementKindExpr(i))throw new Error("element kind and tag expressions are not supported in deployment view rules");if(D.isDeploymentRef(i)){const e=i.ref.deployment;if(i.selector==="expanded"){const t=e+".";return n=>n.id===e||n.id.startsWith(t)}if(i.selector==="descendants"){const t=e+".";return n=>n.id.startsWith(t)}return i.selector==="children"?t=>Le(t.id)===e:t=>t.id===e}if(D.isModelRef(i)){const e=i.ref.model;if(i.selector==="expanded"){const t=e+".";return n=>{const r=n.modelRef??null;return r?r===e||r.startsWith(t):!0}}if(i.selector==="descendants"){const t=e+".";return n=>{const r=n.modelRef??null;return r?r.startsWith(t):!0}}return i.selector==="children"?t=>{const n=t.modelRef??null;return n?Le(n)===e:!0}:t=>{const n=t.modelRef??null;return n?n===e:!0}}de(i)}function Ii(i){return wt(i.$instance)??wt(i.element.$element)}function $o(i){const e=i.id,t=i.onlyOneInstance();return ue({id:e,deploymentRef:e,title:i.title,kind:i.kind,technology:i.technology??void 0,links:ce(i.links,1)?[...i.links]:void 0,notation:i.$node.notation??void 0,color:i.color,shape:i.shape,modelRef:t?.element.id,icon:i.style.icon,description:wt(i.$node)??void 0,tags:[...i.tags],style:wi(i.style,["icon","shape","color"])})}function xo(i){const e=i.$instance,t=i.element,{icon:n,color:r,shape:s,...o}=i.style,a=[...t.links,...e.links??[]];return ue({id:i.id,kind:"instance",title:i.title,description:Ii(i)??void 0,technology:i.technology??void 0,tags:[...i.tags],links:ce(a,1)?a:void 0,icon:n,color:r,shape:s,style:o,deploymentRef:e.id,modelRef:t.id,notation:e.notation})}function _o(i){return i.isInstance()?xo(i):$o(i)}function ko(i){return i.reduce((e,t)=>{const n=[...t.relations.model,...t.relations.deployment];L(ce(n,1),"Edge must have at least one relation");const r=t.source.$model.$styles.defaults,s=t.source.id,o=t.target.id,{title:a,color:c=r.relationship.color,line:u=r.relationship.line,head:d=r.relationship.arrow,...l}=Ai(n.map(m=>m.$relationship)),h=ue({id:t.id,parent:t.boundary?.id??null,source:s,target:o,label:a??null,relations:n.map(m=>m.id),color:c,line:u,head:d,...l}),f=e.find(m=>m.source===o&&m.target===s);if(f&&h.label===f.label){f.dir="both";const m=f.head??h.head??t.source.$model.$styles.defaults.relationship.arrow;return f.head??=m,f.tail??=m,h.color&&(f.color??=h.color),h.line&&(f.line??=h.line),e}return e.push(h),e},[])}function So(i,e){const t=tn(i.$styles,[...e.final].map(_o));for(const n of t.values()){if(!n.deploymentRef||!n.modelRef||n.children.length>0)continue;const r=i.deployment.element(n.deploymentRef),s=r.isDeploymentNode()&&r.onlyOneInstance();if(!s)continue;n.title===r.name&&(n.title=s.title),n.description??=Ii(s)??null,n.technology??=s.technology,He(n.tags)&&(n.tags=[...s.tags]),(!n.links||He(n.links))&&ce(s.links,1)&&(n.links=[...s.links]);const o=i.$styles.defaults;n.shape===o.shape&&n.shape!==s.shape&&(n.shape=s.shape,n.notation=null),n.color===o.color&&n.color!==s.color&&(n.color=s.color,n.notation=null),!n.icon&&s.icon&&(n.icon=s.icon)}return t}function Do(i,e){for(const t of i){if(!Wn(t)||t.targets.length===0)continue;const n=t.targets.map($t);Di(t,oe(n),e)}return e}function Go(i){const e=new We(()=>[]);for(const n of i)for(const r of n.relations.model)e.get(r).push(n);const t=new We(()=>new Set);for(const[n,r]of e)ce(r,2)&&$(r,ie(s=>[{group:`$source-${s.source.id}`,conn:s},{group:`$target-${s.target.id}`,conn:s}]),Ir(bt("group")),Ar(),M(ce(2)),X(Qn(F(bt("conn")),Cr("desc"),Xt((s,o,a)=>o===0||s.boundary===a[o-1].boundary),X(s=>{t.get(s).add(n)}))));return t}function Co(i){i=Ye(i);const e=Go(i);for(const t of i){const{source:n,target:r}=t,s=t.relations.model;if(n.isDeploymentNode()!==r.isDeploymentNode()){const o=n.isDeploymentNode()?n:t.target;L(o.isDeploymentNode());const a=o.internalModelRelationships(),c=se(s,a);for(const u of c)e.get(t).add(u);continue}if(n.isDeploymentNode()&&r.isDeploymentNode()){const o=P(se(t.relations.model,n.internalModelRelationships()),se(t.relations.model,r.internalModelRelationships()));for(const a of o)e.get(t).add(a)}}return $(e.entries(),$r(([t,n])=>t.update({model:n,deployment:null})),R())}function nn(i){return Je(i,Co(i))}function Ao(i){return $(i,Ye,rt((e,t)=>{const{source:n,target:r,relations:s}=t;if(n.isInstance()&&r.isInstance())return e;let o=Er.empty();if(n.isDeploymentNode()&&r.isDeploymentNode()){const[a]=St(r,n,"directed");a&&(o=s.intersect(a.relations))}for(const a of i)br(a,t)&&(o=o.union(s.intersect(a.relations)));return o.nonEmpty&&e.push(new vr(n,r,o)),e},[]))}function rn(i){return Je(i,Ao(i))}let Io=class extends ki{connectWithExisting(e,t="both"){const n=this._connections.length,r=()=>this._connections.length>n;if(!ke(e)){if(t==="in"||t==="both")for(const o of this.memory.elements)this.addConnections(St(o,e,"directed"));return(t==="out"||t==="both")&&this.addConnections(fe(e,this.memory.elements,"directed")),r()}const s=[...e];if(t==="in"||t==="both")for(const o of this.memory.elements)this.addConnections(fe(o,s,"directed"));if(t==="out"||t==="both")for(const o of s)this.addConnections(fe(o,this.memory.elements,"directed"));return r()}processConnections(e){const t=$(e,nn,rn);return $(t,X(({source:n,target:r,boundary:s})=>{$(Jn([...R(n.ancestors()).reverse(),n],[...R(r.ancestors()).reverse(),r]),Xt(([o,a])=>o===a),bi(1),X(([o,a])=>{if(n===o&&r===a){this.addImplicit(s);return}o!==n&&o.isDeploymentNode()&&!o.onlyOneInstance()&&this.addImplicit(o),a!==r&&a.isDeploymentNode()&&!a.onlyOneInstance()&&this.addImplicit(a)}))})),t}},No=class pt extends xi{static empty(){return new pt({elements:new Set,explicits:new Set,final:new Set,connections:[]})}stageInclude(e){return new Io(this,e)}stageExclude(e){return new bo(this,e)}mutableState(){return{elements:new Set(this.state.elements),explicits:new Set(this.state.explicits),final:new Set(this.state.final),connections:[...this.state.connections]}}update(e){return new pt({...this.state,...e})}equals(e){return e instanceof pt&&qn(this.state,e.state)}diff(e){return{added:{elements:R(j(e.elements,this.elements)),explicits:R(j(e.explicits,this.explicits)),final:R(j(e.final,this.final)),connections:R(Je(e.connections,this.connections))},removed:{elements:R(j(this.elements,e.elements)),explicits:R(j(this.explicits,e.explicits)),final:R(j(this.final,e.final)),connections:Je(this.connections,e.connections)}}}toString(){return["final:",...[...this.final].map(e=>"  "+e.id),"connections:",...this.connections.map(e=>"  "+e.expression)].join(`
`)}[ar](e,t,n){return this.toString()}};const Ro={include:({expr:i,model:e,memory:t,stage:n})=>{const r=xe(i.where.condition);return Ze("include",{expr:i.where.expr,model:e,stage:n,memory:t,where:r})},exclude:({expr:i,model:e,memory:t,stage:n})=>{const r=xe(i.where.condition);return Ze("exclude",{expr:i.where.expr,model:e,stage:n,memory:t,where:r})}},Mo={include:({expr:i,model:e,memory:t,stage:n,where:r})=>{const s=[...t.elements];if(D.isWildcard(i.incoming)){for(const a of s){if(a.allOutgoing.isEmpty)continue;const c=[...Xe(a)],u=q(fe(a,c,"directed"),r);n.addConnections(u)}return n}L(D.isDeploymentRef(i.incoming),"Only deployment refs are supported in include");const o=me(e,i.incoming);for(const a of s){const c=q(fe(a,o,"directed"),r);n.addConnections(c)}return n},exclude:({expr:i,model:e,memory:t,stage:n,where:r})=>{if(D.isElementTagExpr(i.incoming)||D.isElementKindExpr(i.incoming))throw new Error("element kind and tag expressions are not supported in exclude");if(D.isModelRef(i.incoming)){const a=Ni(e,i.incoming);return _e(a,{stage:n,memory:t},r)}if(D.isWildcard(i.incoming))return n;const s=Be(me(e,i.incoming)),o=$(t.connections,M(s),q(r));return n.excludeConnections(o),n}};function Be(i){return oe(i.map(e=>{const t=n=>n===e||$e(e,n);return n=>!t(n.source)&&t(n.target)}))}function Ni(i,e){const t=Qe(i,e);return new Set(t.flatMap(n=>[...n.allIncoming]))}const Oo={include:({expr:i,model:e,memory:t,stage:n,where:r})=>{const s=[...t.elements];if(D.isWildcard(i.outgoing)){for(const a of s)if(!a.allIncoming.isEmpty)for(const c of Xe(a)){const u=q(St(c,a,"directed"),r);n.addConnections(u)}return n}L(D.isDeploymentRef(i.outgoing),"Only deployment refs are supported in include");const o=me(e,i.outgoing);for(const a of o){const c=q(fe(a,s,"directed"),r);n.addConnections(c)}return n},exclude:({expr:i,model:e,memory:t,stage:n,where:r})=>{if(D.isElementTagExpr(i.outgoing)||D.isElementKindExpr(i.outgoing))throw new Error("element kind and tag expressions are not supported in exclude");if(D.isModelRef(i.outgoing)){const a=jt(e,i.outgoing);return _e(a,{stage:n,memory:t},r)}if(D.isWildcard(i.outgoing))return n;const s=Ve(me(e,i.outgoing)),o=$(t.connections,M(s),q(r));return n.excludeConnections(o),n}};function Ve(i){return oe(i.map(e=>{const t=n=>n===e||$e(e,n);return n=>t(n.source)&&!t(n.target)}))}function jt(i,e){const t=Qe(i,e);return new Set(t.flatMap(n=>[...n.allOutgoing]))}const Xe=i=>{const e=new Set;for(let t of i.descendingSiblings())e.add(t);return e},Lo={include:({expr:{source:i,target:e,isBidirectional:t=!1},model:n,stage:r,where:s})=>{if(D.isElementTagExpr(i)||D.isElementKindExpr(i))throw new Error("element kind and tag expressions are not supported in include");if(D.isElementTagExpr(e)||D.isElementKindExpr(e))throw new Error("element kind and tag expressions are not supported in include");L(!D.isModelRef(i),"Invalid source model ref in direct relation"),L(!D.isModelRef(e),"Invalid target model ref in direct relation");const o=D.isWildcard(i),a=D.isWildcard(e),c=t?"both":"directed";let u;switch(!0){case(o&&a):{u=$(st(n.instances()),q(s),F(d=>(r.addImplicit(d.boundary),d)));break}case(!o&&a):{const d=me(n,i),l=Ve(d);let h=l;if(t){const f=Be(d);h=m=>l(m)!==f(m)}u=$(d,ie(f=>{const m=Xe(f);return fe(f,m,c)}),M(h),q(s));break}case(o&&!a):{const d=me(n,e),l=Be(d);let h=l;if(t){const f=Ve(d);h=m=>f(m)!==l(m)}u=$(d,ie(f=>[...Xe(f)].flatMap(x=>St(x,f,c))),M(h),q(s));break}default:{L(!o,"Inferrence failed - source should be a deployment ref"),L(!a,"Inferrence failed - target should be a deployment ref");const d=me(n,i),l=me(n,e),h=Ve(d),f=Be(l);u=$(d,ie(m=>fe(m,l,c)),M(m=>h(m)&&f(m)),q(s))}}return r.addConnections(u),D.isDeploymentRef(i)&&pn(i.selector)&&r.addImplicit(n.element(i.ref.deployment)),D.isDeploymentRef(e)&&pn(e.selector)&&r.addImplicit(n.element(e.ref.deployment)),r},exclude:({expr:i,model:e,memory:t,stage:n,where:r})=>{const s=$t(i.target),o=$t(i.source);let a;switch(!0){case(D.isWildcard(i.source)&&D.isWildcard(i.target)):return n.excludeConnections(q(t.connections,r)),n;case(D.isModelRef(i.source)&&D.isModelRef(i.target)):return a=Wo({source:i.source,target:i.target,expr:i,model:e}),_e(a,{stage:n,memory:t},r);case(D.isModelRef(i.source)&&D.isWildcard(i.target)):return a=jt(e,i.source),_e(a,{stage:n,memory:t},r);case D.isModelRef(i.source):return a=jt(e,i.source),_e(a,{stage:n,memory:t},r,d=>s(d.target));case D.isModelRef(i.target):return a=Ni(e,i.target),_e(a,{stage:n,memory:t},r,d=>o(d.source));default:const c=d=>o(d.source)&&s(d.target)||i.isBidirectional===!0&&o(d.target)&&s(d.source),u=$(t.connections,M(c),q(r));return u.length===0||n.excludeConnections(u),n}}};function Wo({source:i,target:e,expr:t,model:n}){const r=Qe(n,i),s=Qe(n,e),o=t.isBidirectional?"both":"directed",a=[];for(const c of r)a.push(...wr(c,s,o));return new Set(a.flatMap(c=>[...c.relations]))}const To={include:({expr:i,model:e,memory:t,stage:n,where:r})=>{const s=[...t.elements];if(D.isWildcard(i.inout)){for(const a of s){const c=[...Xe(a)],u=In(fe(a,c,"both"),r);n.addConnections(u)}return n}L(D.isDeploymentRef(i.inout),"Only deployment refs are supported in include");const o=me(e,i.inout);for(const a of s){const c=In(fe(a,o,"both"),r);n.addConnections(c)}return n},exclude:({expr:i,model:e,memory:t,stage:n,where:r})=>{if(D.isElementTagExpr(i.inout)||D.isElementKindExpr(i.inout))throw new Error("element kind and tag expressions are not supported in exclude");if(D.isModelRef(i.inout)){const u=Qe(e,i.inout);if(u.length===0)return n;const d=P(new Set,...u.flatMap(l=>[l.allIncoming,l.allOutgoing]));return _e(d,{stage:n,memory:t},r)}if(D.isWildcard(i.inout))return n;const s=me(e,i.inout),o=Be(s),a=Ve(s),c=$(t.connections,M(u=>o(u)!==a(u)),q(r));return n.excludeConnections(c),n}},jo={include:({expr:i,model:e,memory:t,stage:n})=>{const r=xe(i.where.condition);return Ze("include",{expr:i.where.expr,model:e,stage:n,memory:t,where:r})},exclude:({expr:i,model:e,memory:t,stage:n})=>{const r=xe(i.where.condition);return Ze("exclude",{expr:i.where.expr,model:e,stage:n,memory:t,where:r})}},Po={include:({model:i,stage:e,where:t})=>{const n=[],r=$([...i.roots()],ye(t),F(s=>(s.onlyOneInstance()||n.push(...s.children()),s)));return e.addExplicit(r),n.length>1&&e.addConnections(st([...r,...n])),e},exclude:({stage:i,memory:e,where:t})=>{const n=$([...e.elements],ye(t));return i.exclude(n),i}};function Ze(i,{expr:e,where:t,...n}){switch(!0){case D.isElementTagExpr(e):case D.isElementKindExpr(e):throw new Error("element kind and tag expressions are not supported in deployment view rules");case Ce.isCustom(e):case D.isCustom(e):case D.isModelRef(e):return;case D.isWhere(e):return Ro[i]({...n,expr:e,where:t});case Ce.isWhere(e):return jo[i]({...n,expr:e,where:t});case D.isDeploymentRef(e):return Uo[i]({...n,expr:e,where:t});case D.isWildcard(e):return Po[i]({...n,expr:e,where:t});case Ce.isDirect(e):return Lo[i]({...n,expr:e,where:t});case Ce.isInOut(e):return To[i]({...n,expr:e,where:t});case Ce.isOutgoing(e):return Oo[i]({...n,expr:e,where:t});case Ce.isIncoming(e):return Mo[i]({...n,expr:e,where:t});default:de(e)}}function _e(i,{stage:e,memory:t},n,r=()=>!0){if(i.size===0)return e;const s=$(t.connections,M(o=>r(o)),M(o=>Yn(o.relations.model,i)),F(o=>o.update({deployment:null,model:se(o.relations.model,i)})),q(n),M(o=>o.nonEmpty()));return s.length===0?e:e.excludeConnections(s)}function zo(i,e){return q(i,e).nonEmpty()}function q(...i){if(i.length===1)return n=>q(n,i[0]);const[e,t]=i;return t===null?e:ei(e)?e.map(n=>q(n,t)).filter(n=>n.nonEmpty()):e.update({model:new Set([...e.relations.model.values()].filter(n=>t(Nn(e)(n)))),deployment:new Set([...e.relations.deployment.values()].filter(n=>t(Nn(e)(n))))})}function ye(...i){if(i.length===1)return n=>ye(n,i[0]);const[e,t]=i;return ei(e)?e.filter(n=>ye(n,t)):t?.(Pt(e,e))??!0}function In(i,e){return e?$(i,M(t=>zo(t,e))):i}function Pt(i,e){if(Sr(i)){const t=Nr(e)&&Ot(e)?e:null;return{kind:i.kind,tags:[...i.tags,...t?.tags??[]]}}if(Dr(i))return yt(i.element,["tags","kind"]);if(Ot(i))return{kind:i.element.kind,tags:[...i.tags,...i.element.tags]};if(Gr(i))return yt(i,["tags","kind"]);de(i)}function Nn(i){return e=>({tags:e.tags,kind:e.kind,source:Pt(e.source,i.source),target:Pt(e.target,i.target)})}const Uo={include:i=>{const{expr:e,where:t}=i,n=i.model.element(e.ref.deployment);if(Ot(n))return ye(n,t)&&(i.stage.addExplicit(n),i.stage.connectWithExisting(n)),i.stage;switch(!0){case e.selector==="expanded":Ko(n,i);break;case e.selector==="children":Fo(n,i);break;case e.selector==="descendants":qo(n,i);break;default:ye(n,t)&&(i.stage.addExplicit(n),i.stage.connectWithExisting(n))}return i.stage},exclude:({expr:i,stage:e,memory:t,where:n})=>{const r=$t(i),s=$([...t.elements],M(r),ye(n));return e.exclude(s),e}};function Fo(i,{stage:e,where:t}){const n=ye([...i.children()],t);n.length!==0&&(e.addImplicit(i),e.addConnections(st(n)),e.connectWithExisting(n),e.addExplicit(n))}function Ko(i,{memory:e,stage:t,where:n}){t.addImplicit(i),t.connectWithExisting(i);const r=ye([...i.children()],n);let s=!1;for(const o of r)if(fe(o,e.elements).length>0){s=!0;break}s&&(t.connectWithExisting(r,"in"),t.addConnections(st(r)),t.connectWithExisting(r,"out")),t.addImplicit(r),t.connections.length>0&&t.addExplicit(i)}function qo(i,{stage:e,where:t}){const n=o=>{const a=[];for(const c of o.children())c.isDeploymentNode()&&a.push(...n(c)),ye(c,t)&&a.push(c);return e.connectWithExisting(a,"in"),e.addConnections(st(a)),e.addImplicit(a),a},r=n(i);if(r.length===0)return;e.connectWithExisting(r,"out");const s=Bo(e);$(r,M(o=>s.has(o)),X(o=>e.addExplicit(o)))}function Bo(i){return $(i.mergedConnections(),nn,rn,rt((e,t)=>(e.add(t.source),e.add(t.target),e),new Set))}let Vo=class Ri{constructor(e){this.memory=e}static for(e){return new Ri(e)}step1CleanConnections(e){if(e.connections.length<2)return e;const t=$(e.connections,nn,rn),n=Je(e.connections,t);if(n.length===0)return e;const r=e.stageExclude({});return r.excludeConnections(n,!0),r.commit()}step2ProcessImplicits(e){const t=P(this.memory.elements,e.elements),n=P(e.final,this.memory.explicits),r=new We(()=>new Set);for(const a of e.connections)if(a.boundary)for(const c of a.relations.model)r.get(c).add(a.boundary);for(const[a,c]of r)if(!(c.size<2))for(const u of c)t.delete(u)&&n.add(u);const s=new Set(n),o=a=>{for(const c of s)if(a===c||$e(a,c))return!0;return!1};return $(j(t,s),J(a=>a.isDeploymentNode()),R(),Bn,X(a=>{const c=[...a.children()].filter(o).length;if(c>=2){n.add(a);return}c===1&&Vt(a.siblings(),o)&&n.add(a)})),e.update({final:n})}step3ProcessBoundaries(e){const t=new Set;for(const a of e.connections)a.boundary&&t.add(a.boundary);const n=Si(e,"final"),r=e.stageExclude({}),s=a=>!(t.has(a)||e.explicits.has(a)||n.hasInOut(a)||n.root.has(a)),o=z([...n.root]);o&&!e.explicits.has(o)&&r.exclude(o);for(const a of e.final){const c=z(n.children(a));c&&!n.hasInOut(c)&&s(a)&&r.exclude(a)}return r.isDirty()?r.commit():e}commit(){const e=this.step1CleanConnections(this.memory),t=this.step2ProcessImplicits(e);return this.step3ProcessBoundaries(t)}};function Ho(i,e){let t=No.empty();for(const n of e)if(xt(n)){const r="include"in n?"include":"exclude",s=n.include??n.exclude;for(const o of s){let a=r==="include"?t.stageInclude(o):t.stageExclude(o);a=Ze(r,{expr:o,model:i,stage:a,memory:t,where:null})??a,t=a.commit()}}return Vo.for(t).commit()}function Jo(i,{docUri:e,rules:t,...n}){const r=Ho(i.deployment,t),s=So(i,r),o=ko(r.connections);Ei(s,o);const a=$i({nodes:s,edges:o}),c=Do(t,a.nodes),u=Zt(t,Bt),d=qt(c);return en({...n,[Kt]:"computed",[Fn]:"deployment",autoLayout:{direction:u?.direction??"TB",...u?.nodeSep&&{nodeSep:u.nodeSep},...u?.rankSep&&{rankSep:u.rankSep}},edges:a.edges,nodes:F(c,l=>(l.icon==="none"&&delete l.icon,l)),...d.length>0&&{notation:{nodes:d}}})}function sn(i){return e=>Pn(e)?e.groupRules.flatMap(sn(i)):xt(e)?"include"in e?e.include.filter(i):[]:[]}function Mi(i,e){const t=i.flatMap(sn(C.isCustom));if(t.length===0)return e;const n=[...e];for(const{custom:{expr:r,...s}}of t){const{border:o,opacity:a,multiple:c,padding:u,size:d,textSize:l,description:h,...f}=zn(s,Se),m=ue({border:o,opacity:a,multiple:c,padding:u,size:d,textSize:l}),x=!He(m),b=!He(f),A=te(r);n.forEach((S,N)=>{Un(S)||!A(S)||(b&&(S={...S,isCustomized:!0,...f}),h!==void 0&&(S={...S,isCustomized:!0,description:h}),x&&(S={...S,isCustomized:!0,style:{...S.style,...m}}),n[N]=S)})}return n}function Yo(i,e){return i.reduce((t,n)=>{if(Tn(n)){const r=e.predicates[n.predicateId];return Se(r)?t:t.concat(r)}if(jn(n)){const r=e.styles[n.styleId];return Se(r)?t:t.concat(r)}return t.push(n),t},[])}function Qo(i,e){return i.reduce((t,n)=>{if(Tn(n)){const r=e.dynamicPredicates[n.predicateId];return Se(r)?t:t.concat(r)}if(jn(n)){const r=e.styles[n.styleId];return Se(r)?t:t.concat(r)}return t.push(n),t},[])}function Xo(i,e){const t=new Set;for(const n of e)if(xt(n))for(const r of n.include){const s=te(r);for(const o of i.elements())s(o)&&t.add(o)}return t}const Zo=i=>{if(Ln(i)){const e=[],t=[];for(const n of i.__parallel)if(Mt(n)){const[r,...s]=n.__series;e.push(r),t.push(...s)}else e.push(n);return[...e,...t]}return Mt(i)?[...i.__series]:i};function ea(i,e){const t=[],n=(...[r,s])=>{if(!t.includes(r)){const o=t.indexOf(s);if(o>0){t.splice(o,0,r);return}else t.push(r)}t.includes(s)||t.push(s)};for(const r of ie(e,Zo)){const s=i.element(r.source),o=i.element(r.target);let a=t.indexOf(s),c=t.indexOf(o);a>=0&&c>=0||(r.isBackward?n(o,s):n(s,o))}return new Set(t)}function ta(i,e,t){const n=ur(i,e,"directed").flatMap(d=>[...d.relations]).sort(dr);if(!Vn(n))return{};if(n.length===1){const d=n[0];return ue({title:d.title??void 0,tags:d.tags,relations:[d.id],navigateTo:d.$relationship.navigateTo,color:d.$relationship.color,line:d.$relationship.line})}const r=$(n,ie(d=>d.tags),Te()),s=ce(r,1)?r:void 0,o=F(n,d=>d.id);let c=Js(n).$relationship.navigateTo;c===t&&(c=void 0),c||(c=$(n,ie(d=>d.$relationship.navigateTo&&d.$relationship.navigateTo!==t?d.$relationship.navigateTo:[]),Te(),z()));const u=$(n,rt((d,{title:l,$relationship:h})=>(K(l)&&d.title.add(l),K(h.color)&&d.color.add(h.color),K(h.line)&&d.line.add(h.line),K(h.kind)&&d.kind.add(h.kind),d),{kind:new Set,color:new Set,line:new Set,title:new Set}));return ue({tags:s??void 0,relations:o,navigateTo:c,kind:z([...u.kind]),title:z([...u.title]),color:z([...u.color]),line:z([...u.line])})}class na{constructor(e,t){this.model=e,this.view=t}steps=[];compute(){const{docUri:e,rules:t,steps:n,...r}=this.view,s=Qo(t,this.model.globals),o=Xo(this.model,s),a=ea(this.model,n),c=$(P(se(o,a),a,o),R(),mt),u=c.reduce((S,N,g,p)=>{for(let y=g+1;y<p.length;y++){const E=p[y];if($e(N,E)){S.push(N);break}}return S},[]),d=(S,N,g)=>{if(Mt(S)){for(const Vi of S.__series)N=d(Vi,N,g);return N}const p=g?ln(g,N):ln(N),{source:y,target:E,title:_,isBackward:I,navigateTo:G,notation:H,...W}=S,Y=this.model.element(y),ot=c.indexOf(Y);L(ot>=0,`Source ${y} not found`);const Ue=this.model.element(E),cn=c.indexOf(Ue);L(cn>=0,`Target ${E} not found`),(u.includes(Y)||u.includes(Ue))&&console.error(`Step ${Y.id} -> ${Ue.id} because it involves a compound`);const{title:Ui,relations:Fi,navigateTo:Ki,...qi}=ta(Y,Ue,this.view.id),Bi=K(G)&&G!==this.view.id?G:Ki;return this.steps.push(ue({...qi,...W,id:p,source:Y,target:Ue,navigateTo:Bi,title:_??Ui,relations:Fi??[],isBackward:ot>cn})),N+1};let l=1;for(const S of n){if(Ln(S)){let N=1;for(const g of S.__parallel)N=d(g,N,l);l++;continue}l=d(S,l)}const h=tn(this.model.$styles,c.map(Ci)),f=this.model.$styles.defaults.relationship,m=this.steps.map(({id:S,source:N,target:g,relations:p,title:y,isBackward:E,tags:_,...I})=>{const G=re(h.get(N.id),`Source node ${N.id} not found`),H=re(h.get(g.id),`Target node ${g.id} not found`),W={id:S,parent:Zi(N.id,g.id),source:G.id,target:H.id,label:y??null,relations:p,color:f.color,line:f.line,head:f.arrow,tags:_??[],...I};for(E&&(W.dir="back");W.parent&&!h.has(W.parent);)W.parent=Le(W.parent);G.outEdges.push(W.id),H.inEdges.push(W.id);for(const Y of un(W.source)){if(Y===W.parent)break;h.get(Y)?.outEdges.push(W.id)}for(const Y of un(W.target)){if(Y===W.parent)break;h.get(Y)?.inEdges.push(W.id)}return W}),x=Mi(s,Gi(s,c.map(S=>re(h.get(S.id))))),b=Zt(s,Bt),A=qt(x);return en({...r,[Fn]:"dynamic",[Kt]:"computed",variant:r.variant??"diagram",autoLayout:{direction:b?.direction??"LR",...b?.nodeSep&&{nodeSep:b.nodeSep},...b?.rankSep&&{rankSep:b.rankSep}},nodes:F(x,S=>(S.icon==="none"&&delete S.icon,S)),edges:m,...A.length>0&&{notation:{nodes:A}}})}}function ia(i,e){return new na(i,e).compute()}function zt(i){switch(!0){case Z.isCustom(i):return zt(i.customRelation.expr);case Z.isWhere(i):{const e=zt(i.where.expr),t=xe(i.where.condition);return n=>e(n)&&t({source:{tags:n.source.tags,kind:n.source.kind},target:{tags:n.target.tags,kind:n.target.kind},...n.tags&&{tags:n.tags},...n.kind&&{kind:n.kind}})}case Z.isDirect(i):{const e=te(i.source),t=te(i.target);return n=>e(n.source)&&t(n.target)||!!i.isBidirectional&&e(n.target)&&t(n.source)}case Z.isInOut(i):{const e=te(i.inout);return t=>e(t.source)||e(t.target)}case Z.isIncoming(i):{const e=te(i.incoming);return t=>e(t.target)}case Z.isOutgoing(i):{const e=te(i.outgoing);return t=>e(t.source)}default:de(i)}}function ra(i,e,t){const n=i.flatMap(sn(Z.isCustom)),r=Array.from(t);if(n.length===0||r.length===0)return r;for(const{customRelation:{expr:s,title:o,description:a,notes:c,...u}}of n){const d=a?{description:{txt:a}}:{},l=c?{notes:{txt:c}}:{},h=zn(u,Se),f=zt(s);r.forEach((m,x)=>{let b,A;for(const S of e)if(S.id===m.source&&(b=S),S.id===m.target&&(A=S),b&&A)break;!b||!A||f({source:b,target:A,...yt(m,["kind","tags"])})&&(r[x]={...m,...h,...d,...l,label:o??m.label,isCustomized:!0})})}return r}class et{constructor(e,t,n=null,r=new Set){this.id=e,this.viewRule=t,this.parent=n,this.elements=r}static kind=Kn;isEmpty(){return this.elements.size===0}update(e){return new et(this.id,this.viewRule,this.parent,e)}clone(){return new et(this.id,this.viewRule,this.parent,new Set(this.elements))}}class Oi extends _i{excludeRelations(e){return $(this.memory.connections,M(t=>Yn(t.relations,e)),X(t=>{this.excludeConnections(t.update(se(t.relations,e)))})),this}precommit(e){if(this.excluded.elements.size>0){const t=new Set([...this.excluded.elements].flatMap(n=>[...n.incoming("direct"),...n.outgoing("direct")]));this.excludeRelations(t)}return e}postcommit(e){const t=j(this.memory.explicits,e.explicits);for(const r of t)e.explicitFirstSeenIn.delete(r);const n=j(this.memory.elements,e.elements);for(const r of n)e.lastSeenIn.delete(r);return e}}class sa extends Oi{constructor(e,t){super(e,t),this.memory=e,this.expression=t}}const{findConnection:oa,findConnectionsBetween:Nt}=Hn;class Li extends ki{connectWithExisting(e,t="both"){const n=this._connections.length,r=()=>this._connections.length>n;if(!ke(e)){if(t==="in"||t==="both")for(const o of this.memory.elements)this.addConnections(oa(o,e,"directed"));return(t==="out"||t==="both")&&this.addConnections(Nt(e,this.memory.elements,"directed")),r()}const s=[...e];if(t==="in"||t==="both")for(const o of this.memory.elements)this.addConnections(Nt(o,s,"directed"));if(t==="out"||t==="both")for(const o of s)this.addConnections(Nt(o,this.memory.elements,"directed"));return r()}addImplicitWithinScope(e){e&&(!this.memory.scope||$e(this.memory.scope,e))&&this.addImplicit(e)}processConnections(e){return Rt.isRelationExpr(this.expression)||$(e,X(({source:t,target:n,boundary:r})=>{$(Jn([...R(t.ancestors()).reverse(),t],[...R(n.ancestors()).reverse(),n]),Xt(([s,o])=>s===o),bi(1),X(([s,o])=>{if(s===t&&o===n){this.addImplicitWithinScope(r);return}s!==t&&this.addImplicitWithinScope(s),o!==n&&this.addImplicitWithinScope(o)}))})),e}postcommit(e){const t=j(e.explicits,this.memory.explicits);for(const n of t)e.explicitFirstSeenIn.set(n,"@root");return e}}class aa extends Li{constructor(e,t){super(e,t),this.memory=e,this.expression=t}postcommit(e){const t=j(e.explicits,this.memory.explicits);for(const n of t)e.explicitFirstSeenIn.set(n,this.memory.activeGroupId);for(const n of[...this.explicits,...this.implicits])e.lastSeenIn.set(n,this.memory.activeGroupId);return e}}class De extends xi{constructor(e,t){super(e),this.state=e,this.scope=t}static empty(e){return new De({elements:new Set,explicits:new Set,final:new Set,connections:[],groups:[],explicitFirstSeenIn:new Map,lastSeenIn:new Map},e)}get groups(){return this.state.groups}get explicitFirstSeenIn(){return this.state.explicitFirstSeenIn}get lastSeenIn(){return this.state.lastSeenIn}stageInclude(e){return new Li(this,e)}stageExclude(e){return new Oi(this,e)}mutableState(){return{elements:new Set(this.state.elements),explicits:new Set(this.state.explicits),final:new Set(this.state.final),connections:[...this.state.connections],groups:this.state.groups.map(e=>e.clone()),explicitFirstSeenIn:new Map(this.state.explicitFirstSeenIn),lastSeenIn:new Map(this.state.lastSeenIn)}}update(e){return new De({...this.state,...e},this.scope)}}class ve extends De{constructor(e,t,n){super(e,t),this.state=e,this.scope=t,this.stack=n}static enter(e,t){const n=`@gr${e.groups.length+1}`;if(e instanceof ve){const o=fn.from([...e.stack].reverse()),a=e.mutableState();return a.groups.push(new et(n,t,e.activeGroupId)),o.push(n),new ve(a,e.scope,o)}const r=e.mutableState();r.groups.push(new et(n,t,null));const s=fn.of(n);return new ve(r,e.scope,s)}get activeGroupId(){return re(this.stack.peek(),"Stack must not be empty")}mutableState(){return{...super.mutableState()}}update(e){const t={...this.state,...e};return new ve(t,this.scope,this.stack)}stageInclude(e){return new aa(this,e)}stageExclude(e){return new sa(this,e)}leave(){const e=this.mutableState();return this.stack.pop(),this.stack.peek()?new ve(e,this.scope,this.stack):new De(e,this.scope)}}function ca(i){return $([...i],Ye,rt((e,t,n,r)=>{const s=fr(r,t),o=P(...s.map(bt("relations")));let a=se(t.relations,o);if(s.length>0&&(a=P(a,t.directRelations)),pr(r,t.reversed(!1))&&(a=P(a,t.directRelations)),a.size<t.relations.size){const c=r.some(mn(t.source)),u=r.some(mn(t.target));c&&(a=P(a,ge(J(t.relations,gr(t.source))))),u&&(a=P(a,ge(J(t.relations,mr(t.target)))))}return a.size>0&&e.push(t.update(a)),e},[]))}class on{constructor(e){this.memory=e}static for(e){return new on(e)}step1CleanConnections(e){if(e.connections.length<2)return e;const t=ca(e.connections);if(t.length===0)return e;const n=e.stageExclude({});return n.excludeConnections(t,!0),n.commit()}step2ProcessImplicits(e){const t=P(this.memory.elements,e.elements),n=P(e.final,this.memory.explicits),r=new Set(n),s=o=>{for(const a of r)if(o===a||$e(o,a))return!0;return!1};return $(j(t,r),R(),Bn,X(o=>{const a=[...o.children()].filter(s).length;if(a>=2){n.add(o);return}a===1&&Vt(o.siblings(),s)&&n.add(o)})),e.update({final:n})}step3ProcessBoundaries(e){const t=new Set;for(const a of e.connections)a.boundary&&a.boundary!==a.source&&a.boundary!==a.target&&t.add(a.boundary);const n=Si(e,"final"),r=e.stageExclude({}),s=a=>!(t.has(a)||e.explicits.has(a)||n.hasInOut(a)||n.root.has(a)),o=z([...n.root]);o&&!e.explicits.has(o)&&r.exclude(o);for(const a of e.final){const c=z(n.children(a));c&&!n.hasInOut(c)&&s(a)&&r.exclude(a)}return r.isDirty()?r.commit():e}commit(){const e=this.step1CleanConnections(this.memory),t=this.step2ProcessImplicits(e);return this.step3ProcessBoundaries(t)}}const{findConnection:ua,findConnectionsBetween:pe,findConnectionsWithin:Ge}=Hn;function V(i,e){switch(!0){case C.isElementKindExpr(e):return[...J(i.elements(),t=>e.isEqual===(t.kind===e.elementKind))];case C.isElementTagExpr(e):return[...J(i.elements(),t=>e.isEqual===t.tags.includes(e.elementTag))];case e.selector==="expanded":{const t=i.element(Q.flatten(e.ref));return[t,...t.children()]}case e.selector==="children":case e.selector==="descendants":{const t=i.element(Q.flatten(e.ref));let n=e.selector==="children"?R(t.children()):R(t.descendants());return n&&n.length>0?n:[t]}case C.isModelRef(e):return[i.element(Q.flatten(e.ref))];default:de(e)}}function gt(i,e){if(e.isEmpty()||i.length===0)return i;const t=oe(i.map(r=>Zn(r))),n=R(J(e.elements,r=>!i.includes(r)&&t(r)));return[...i,...n]}function tt(i,{memory:e,model:t}){const n=V(t,i);return C.isModelRef(i)?i.selector==="descendants"?n:gt(n,e):n}const da={include:({expr:i,model:e,stage:t,where:n})=>{const r=e.element(Q.flatten(i.ref));n(r)&&(t.addExplicit(r),t.connectWithExisting(r));const s=[...r.children()].filter(n),o=[];for(const a of s)t.addImplicit(a),t.connectWithExisting(a)&&o.push(a);return t.addConnections(Ge(o)),t},exclude:({expr:i,model:e,stage:t,filterWhere:n})=>{const r=n(V(e,i));return t.exclude(r),t}},la={include:({expr:i,model:e,stage:t,filterWhere:n})=>{const r=n(V(e,i));if(r.length!==0)return t.addExplicit(r),t.connectWithExisting(r),t.addConnections(Ge(r)),t},exclude:({expr:i,model:e,stage:t,filterWhere:n})=>{const r=n(V(e,i));return t.exclude(r),t}},ha={include:({expr:i,model:e,stage:t,filterWhere:n})=>{const r=n(V(e,i));if(r.length!==0)return t.addExplicit(r),t.connectWithExisting(r),t.addConnections(Ge(r)),t},exclude:({expr:i,model:e,stage:t,filterWhere:n})=>{const r=n(V(e,i));return t.exclude(r),t}},Me=()=>!0,fa=i=>i;function pa(i){return i.reduce((e,t)=>{const n=[...t.relations];L(ce(n,1),"Edge must have at least one relation");const r=t.source.$model.$styles.defaults,s=t.source.id,o=t.target.id,{title:a,color:c=r.relationship.color,line:u=r.relationship.line,head:d=r.relationship.arrow,...l}=Ai(n.map(f=>f.$relationship),z(M(n,f=>f.source.id===s&&f.target.id===o))?.$relationship),h=ue({id:t.id,parent:t.boundary?.id??null,source:s,target:o,label:a??null,relations:n.map(f=>f.id),color:c,line:u,head:d,...l});return e.push(h),e},[])}function ga(i,e){return tn(i.$styles,[...e.final].map(Ci),e.groups)}const Ee=C.isWildcard,ht=(i,e)=>i.isAncestorOf(e)||i.isDescendantOf(e),ma={include:({expr:{source:i,target:e,isBidirectional:t=!1},memory:n,model:r,stage:s,where:o,filterWhere:a})=>{const c=Ee(i),u=Ee(e),d=[];switch(!0){case(c&&u&&n.isEmpty()&&o!==Me):{const l=$(r.relationships(),J(o),R(),F(h=>new Ne(h.source,h.target,new Set([h]))));return s.addConnections(l),s}case(c&&u&&!n.isEmpty()&&o!==Me):{d.push(...Ge(n.elements));break}case(c&&u):{d.push(...Ge(r.roots()));break}case(!c&&u&&o!==Me):{const l=V(r,i),h=$(l,ie(f=>$(f,lt(dt(t===!0),{onTrue:m=>P(m.allIncoming,m.allOutgoing),onFalse:m=>m.allOutgoing}),J(o),Xn(),R(),vt(m=>m.source===f),([m,x])=>gn($(m,M(b=>!ht(f,b.target)),F(b=>new Ne(f,b.target,new Set([b])))),$(x,M(b=>!ht(f,b.source)),F(b=>new Ne(b.source,f,new Set([b]))))))));return s.addConnections(h),s}case(!c&&u):{const[l,h]=Rn(i,{memory:n,model:r}),f=t?"both":"directed";for(const m of l)d.push(...pe(m,h,f));break}case(c&&!u&&o!==Me):{const l=V(r,e),h=$(l,ie(f=>$(f,lt(dt(t===!0),{onTrue:m=>P(m.allIncoming,m.allOutgoing),onFalse:m=>m.allIncoming}),J(o),R(),vt(m=>m.target===f),([m,x])=>gn($(x,M(b=>!ht(f,b.target)),F(b=>new Ne(f,b.target,new Set([b])))),$(m,M(b=>!ht(f,b.source)),F(b=>new Ne(b.source,f,new Set([b]))))))));return s.addConnections(h),s}case(c&&!u):{const[l,h]=Rn(e,{memory:n,model:r}),f=t?"both":"directed";for(const m of h)d.push(...pe(m,l,f));break}default:{L(!Ee(i),"Inference failed - source must be not a wildcard"),L(!Ee(e),"Inference failed - target must be not a wildcard");const l=tt(i,{memory:n,model:r}),h=tt(e,{memory:n,model:r}),f=t?"both":"directed";for(const m of l)d.push(...pe(m,h,f))}}return s.addConnections(a(d)),s},exclude:({expr:{source:i,target:e,isBidirectional:t},model:n,memory:r,stage:s,where:o})=>{const a=Ee(i),c=Ee(e);let u;switch(!0){case(a&&c):{u=$(r.connections,ie(Qn(bt("relations"),J(o),R())),ge());break}case(!a&&c):{const d=V(n,i);u=$(d,ie(l=>$(l,lt(dt(t===!0),{onTrue:h=>P(h.allIncoming,h.allOutgoing),onFalse:h=>h.allOutgoing}),J(o),R())),ge());break}case(a&&!c):{const d=V(n,e);u=$(d,ie(l=>$(l,lt(dt(t===!0),{onTrue:h=>P(h.allIncoming,h.allOutgoing),onFalse:h=>h.allIncoming}),J(o),R())),ge());break}default:{L(!Ee(i),"Inferrence failed - source must be not a wildcard"),L(!Ee(e),"Inferrence failed - target must be not a wildcard");const d=V(n,i),l=V(n,e);let h=new Set;for(const f of d)for(const m of l)hr(f,m)||(h=P(h,se(f.allOutgoing,m.allIncoming),t?se(m.allOutgoing,f.allIncoming):new Set));u=ge(J(h,o))}}return s.excludeRelations(u),s}};function Rn(i,{memory:e,model:t}){let n=V(t,i);if(!ce(n,1))return[[],[]];if(C.isModelRef(i)){const s=t.element(Q.flatten(i.ref)),o=R(s.ascendingSiblings());return[gt(n,e),gt(o,e)]}const r=$(n,F(s=>s.ascendingSiblings()),kr(),Xn(),R(),s=>gt(s,e));return[n,r]}const ya={include:({expr:i,scope:e,model:t,memory:n,stage:r,filterWhere:s})=>{const o=i.incoming,a=[];if(C.isWildcard(o)){if(!e)return;for(const c of e.ascendingSiblings())a.push(...ua(c,e,"directed"))}else{const c=tt(o,{memory:n,model:t}),u=[...n.elements];u.length===0&&u.push(...Te(c.flatMap(l=>[...l.ascendingSiblings()])));const d=wa(t,o);for(const l of u)a.push(...pe(l,c,"directed").filter(d))}return r.addConnections(s(a)),r},exclude:({expr:{incoming:i},model:e,scope:t,stage:n,where:r})=>{const s=[];if(C.isWildcard(i)){if(!t)return;s.push(...t.allIncoming)}else{const o=V(e,i);s.push(...o.flatMap(a=>[...a.allIncoming]))}return n.excludeRelations(new Set(s.filter(r))),n}};function wa(i,e){switch(!0){case C.isElementKindExpr(e):case C.isElementTagExpr(e):{const t=te(e);return n=>t(n.target)}case(C.isModelRef(e)&&e.selector==="children"):{const t=Q.flatten(e.ref);return oe([...i.children(t)].map(n=>ee.isIncoming(n.id)))}case(C.isModelRef(e)&&e.selector==="descendants"):{const t=Q.flatten(e.ref);return oe([ee.isInside(t),...[...i.children(t)].map(n=>ee.isIncoming(n.id))])}case(C.isModelRef(e)&&e.selector==="expanded"):{const t=Q.flatten(e.ref);return oe([ee.isIncoming(t),ee.isInside(t)])}case C.isModelRef(e):{const t=Q.flatten(e.ref);return ee.isIncoming(t)}default:de(e)}}const ba={include:({expr:{inout:i},scope:e,model:t,memory:n,stage:r,filterWhere:s})=>{const o=[];if(C.isWildcard(i)){if(!e)return;o.push(...pe(e,e.ascendingSiblings()))}else{const a=tt(i,{memory:n,model:t});let c=[...n.elements];c.length===0&&(c=Te(a.flatMap(u=>R(u.ascendingSiblings()))));for(const u of a)o.push(...pe(u,c))}return r.addConnections(s(o)),r},exclude:({expr:{inout:i},model:e,scope:t,stage:n,where:r})=>{const s=[];if(C.isWildcard(i)){if(!t)return;s.push(...t.allOutgoing),s.push(...t.allIncoming)}else{const o=V(e,i);s.push(...o.flatMap(a=>[...a.allOutgoing,...a.allIncoming]))}return n.excludeRelations(ge(s.filter(r))),n}},Ea={include:({expr:i,scope:e,model:t,memory:n,stage:r,filterWhere:s})=>{const o=i.outgoing,a=[];if(C.isWildcard(o)){if(!e)return;a.push(...pe(e,e.ascendingSiblings(),"directed"))}else{const c=tt(o,{memory:n,model:t}),u=[...n.elements];u.length===0&&u.push(...Te(c.flatMap(l=>[...l.ascendingSiblings()])));const d=va(t,o);for(const l of c)a.push(...pe(l,u,"directed").filter(d))}return r.addConnections(s(a)),r},exclude:({expr:{outgoing:i},model:e,scope:t,stage:n,where:r})=>{const s=[];if(C.isWildcard(i)){if(!t)return;s.push(...t.allOutgoing)}else{const o=V(e,i);s.push(...o.flatMap(a=>[...a.allOutgoing]))}return n.excludeRelations(ge(s.filter(r))),n}};function va(i,e){switch(!0){case C.isElementKindExpr(e):case C.isElementTagExpr(e):{const t=te(e);return n=>t(n.source)}case(C.isModelRef(e)&&e.selector==="children"):{const t=Q.flatten(e.ref);return oe([...i.children(t)].map(n=>ee.isOutgoing(n.id)))}case(C.isModelRef(e)&&e.selector==="descendants"):{const t=Q.flatten(e.ref);return oe([ee.isInside(t),...[...i.children(t)].map(n=>ee.isOutgoing(n.id))])}case(C.isModelRef(e)&&e.selector==="expanded"):{const t=Q.flatten(e.ref);return oe([ee.isOutgoing(t),ee.isInside(t)])}case C.isModelRef(e):{const t=Q.flatten(e.ref);return ee.isOutgoing(t)}default:de(e)}}const $a={include:({scope:i,model:e,stage:t,memory:n,where:r})=>{if(!i){const u=[...e.roots()].filter(r);return u.length===0?void 0:(t.addExplicit(u),t.addConnections(Ge(u)),t.connectWithExisting(u),t)}const s=r(i)?i:null,o=R(J(i.children(),r)),a=o.length>0;if(!a)if(s){if(pe(s,s.siblings()).length===0){const d=s.parent;d&&r(d)&&t.addExplicit(d)}o.push(s)}else return t;s&&t.addExplicit(s);const c=ge([...n.elements,...i.descendingSiblings()]);for(const u of c)t.addConnections(pe(u,o,"directed"));a&&(t.addConnections(Ge(o)),t.addExplicit(o));for(const u of o)t.addConnections(pe(u,c,"directed"));return t},exclude:({scope:i,memory:e,stage:t,where:n})=>n!==Me?(t.exclude(M([...e.elements],n)),t):i?(t.exclude([i,...i.descendants()]),t):De.empty(e.scope).stageExclude(t.expression)};function Ut(i,e,t){switch(!0){case C.isCustom(i):return e==="include"?Ut(i.custom.expr,e,t):t.stage;case C.isWhere(i):{const n=xe(i.where.condition),r=s=>M(s,n);return Ut(i.where.expr,e,{...t,where:n,filterWhere:r})}case(C.isModelRef(i)&&i.selector==="expanded"):return da[e]({...t,expr:i})??t.stage;case C.isWildcard(i):return $a[e]({...t,expr:i})??t.stage;case C.isElementKindExpr(i):case C.isElementTagExpr(i):return la[e]({...t,expr:i})??t.stage;case C.isModelRef(i):return ha[e]({...t,expr:i})??t.stage;default:de(i)}}function Ft(i,e,t){switch(!0){case Z.isCustom(i):return e==="include"?Ft(i.customRelation.expr,e,t):t.stage;case Z.isWhere(i):{const n=xe(i.where.condition),r=o=>new Set(M([...o],n)),s=o=>$(o,F(a=>new Ne(a.source,a.target,r(a.relations))),M(a=>a.nonEmpty()));return Ft(i.where.expr,e,{...t,where:n,filterWhere:s})}case Z.isInOut(i):return ba[e]({...t,expr:i})??t.stage;case Z.isDirect(i):return ma[e]({...t,expr:i})??t.stage;case Z.isOutgoing(i):return Ea[e]({...t,expr:i})??t.stage;case Z.isIncoming(i):return ya[e]({...t,expr:i})??t.stage;default:de(i)}}function Wi(i,e,t){const n={model:i,scope:e.scope,where:Me,filterWhere:fa};for(const r of t){if(Pn(r)){const s=ve.enter(e,r);e=Wi(i,s,r.groupRules),L(e instanceof ve,"processPredicates must return ActiveGroupMemory"),e=e.leave();continue}if(xt(r)){const s="include"in r?"include":"exclude",o=r.include??r.exclude;for(const a of o){let c=s==="include"?e.stageInclude(a):e.stageExclude(a);switch(!0){case Rt.isFqnExpr(a):c=Ut(a,s,{...n,stage:c,memory:e})??c;break;case Rt.isRelationExpr(a):c=Ft(a,s,{...n,stage:c,memory:e})??c;break;default:de(a)}e=c.commit()}}}return on.for(e).commit()}function xa(i,{docUri:e,rules:t,...n}){const r=Yo(t,i.globals),s=n.viewOf?i.asComputed.element(n.viewOf):null;let o=Wi(i,De.empty(s),r);o.isEmpty()&&s&&(o=o.update({final:new Set([s])})),o=ka(o);const a=ga(i,o),c=pa(o.connections);Ei(a,c);const u=$i({nodes:a,edges:c}),d=Mi(r,Gi(r,u.nodes)),l=Zt(r,Bt),h=qt(d),f=_a(r,d);return en({...n,_stage:"computed",autoLayout:{direction:l?.direction??"TB",...l?.nodeSep&&{nodeSep:l.nodeSep},...l?.rankSep&&{rankSep:l.rankSep}},edges:ra(r,d,u.edges),nodes:F(d,m=>(m.icon==="none"&&delete m.icon,m)),...h.length>0&&{notation:{nodes:h}},...f.length>0&&{ranks:f}})}function _a(i,e){const t=[];for(const n of i){if(!sr(n)||n.targets.length===0)continue;const r=oe(n.targets.map(te)),s=$(e,M(r),F(o=>o.id));ce(s,1)&&t.push({type:n.rank,nodes:s})}return t}function ka(i){if(i.groups.length===0)return i;const e=new We(()=>new Set),t=new Map,n=o=>{for(const a of o.ancestors()){const c=t.get(a);if(c)return t.set(o,c),e.get(c).add(o),!0}return!1},r=o=>{for(const a of o.descendants("asc")){const c=t.get(a);if(c)return t.set(o,c),e.get(c).add(o),!0}return!1};if($(mt([...i.explicitFirstSeenIn.keys()]),X(o=>{if(!n(o)){const a=re(i.explicitFirstSeenIn.get(o));t.set(o,a),e.get(a).add(o)}})),$(mt([...i.lastSeenIn.keys()]),M(o=>!t.has(o)),X(o=>{if(n(o)||r(o))return;const a=re(i.lastSeenIn.get(o));t.set(o,a),e.get(a).add(o)})),e.size===0)return i;let s=i.groups.map(o=>{const a=e.get(o.id);return a?o.update(a):o});return i.update({groups:s})}function Sa(i,e){switch(!0){case Xi(i):return xa(e,i);case Qi(i):return Jo(e,i);case Yi(i):return ia(e,i);default:de(i)}}function Da(i){const e=On.create(i);let{views:t,_stage:n,...r}=i;const s=Ji(t,o=>Sa(o,e));return{[Kt]:"computed",...r,views:s}}function Ta(i){return On.create(Da(i))}function Ti(){return typeof window>"u"?null:window}async function Ga(i){await new Promise((e,t)=>{const n=document.createElement("script");n.src=i,n.async=!0,n.onload=()=>e(),n.onerror=()=>{const r=new Error("Failed to load "+i);T.error("Failed to load wasm script",{component:"wasm",action:"load_script",scriptUrl:i,error:r.message}),t(r)},document.head.appendChild(n)})}async function Mn(i,e){const t=Ti();if(!t)throw new Re("Window object not available",{configKey:"window"});if(t.Go)return;const n=[i,e.replace(/\/?$/,"/")+"wasm_exec.js","/wasm_exec.js","https://cdn.jsdelivr.net/gh/golang/go@go1.25.0/misc/wasm/wasm_exec.js"];let r=!1,s=null;for(const o of n)try{if(await Ga(o),t.Go){r=!0;break}}catch(a){s=a instanceof Error?a:new Error(String(a))}if(!r){const o=new Et("Failed to load wasm_exec.js from all candidates",{url:i,cause:s||void 0,context:{candidates:n}});throw T.error("Failed to load Go wasm runtime",{component:"wasm",action:"load_go_runtime",candidates:n,error:o.message}),o}}async function ji(i){if(!it())throw new Re("WASM initialization requires browser environment");const e=Ti();if(!e)throw new Re("Window object not available",{configKey:"window"});const t=i?.base||"/",n=t.replace(/\/?$/,"/")+"wasm/wasm_exec.js",r=t.replace(/\/?$/,"/")+"wasm/sruja.wasm",s=r+"?t="+Date.now();if(!i?.skipGoLoad)await Mn(n,t);else if(!e.Go)try{await Mn(n,t)}catch{}const o=e.Go;if(!o){const g=new Re("wasm_exec.js not loaded - Go constructor not available",{configKey:"Go"});throw T.error("Go constructor missing",{component:"wasm",action:"init",errorType:"go_constructor_missing",error:g.message}),g}const a=new o,c=a.importObject||{};if(!c.gojs){const g=c.env||{};c.gojs=Object.keys(g).length?g:c.go||{}}c.gojs["runtime.scheduleTimeoutEvent"]||(c.gojs["runtime.scheduleTimeoutEvent"]=g=>{setTimeout(()=>{try{a._resume&&a._resume()}catch{}},g)});let u=null;const d=[s,r,t.replace(/\/?$/,"/")+"sruja.wasm","/sruja.wasm",t.replace(/\/?$/,"/")+"studio/wasm/sruja.wasm",t.replace(/\/?$/,"/")+"viewer/wasm/sruja.wasm","/wasm/sruja.wasm"];let l=null;for(const g of d)try{const p=await fetch(g);if(!p.ok)throw new Et(`Failed to fetch ${g}`,{url:g,status:p.status});if(WebAssembly.instantiateStreaming)try{u=(await WebAssembly.instantiateStreaming(p,c)).instance,l=null,T.info("WASM loaded via streaming",{component:"wasm",action:"load_wasm",url:g});break}catch(y){T.warn("WASM streaming failed, falling back to arrayBuffer",{component:"wasm",action:"load_wasm",error:y instanceof Error?y.message:String(y)});const E=await fetch(g);if(!E.ok)throw new Error("Failed to re-fetch for fallback");const _=await E.arrayBuffer();u=(await WebAssembly.instantiate(_,c)).instance,l=null;break}else{const y=await p.arrayBuffer();u=(await WebAssembly.instantiate(y,c)).instance,l=null;break}}catch(p){l=p instanceof Error?p:new Error(String(p));continue}if(!u){const g=l||new Et("Failed to load sruja.wasm from all candidates",{context:{candidates:d}});throw T.error("Failed to load sruja.wasm",{component:"wasm",action:"load_wasm",errorType:"wasm_load_failure",candidates:d,retries:d.length,error:g.message}),g}a.run(u),await new Promise(g=>setTimeout(g,100));let h=0;const f=150;for(;!e.sruja_parse_dsl&&h<f;)await new Promise(g=>setTimeout(g,50)),h++;if(h>=f){const g=Object.keys(e).filter(p=>p.startsWith("sruja_"));T.error("Required WASM functions not found after waiting",{component:"wasm",action:"wait_for_required",retries:h,available:g,missing:{parse:!e.sruja_parse_dsl,mermaid:!e.sruja_dsl_to_mermaid,markdown:!e.sruja_dsl_to_markdown}})}const m=e.sruja_parse_dsl,x=e.sruja_json_to_dsl,b=e.sruja_dsl_to_mermaid,A=e.sruja_dsl_to_markdown,S=e.sruja_dsl_to_likec4,N=Object.keys(e).filter(g=>g.startsWith("sruja_"));if(T.info("WASM functions loaded",{component:"wasm",action:"init_complete",available:N}),!m||!x||!b||!A){const g=[];m||g.push("sruja_parse_dsl"),x||g.push("sruja_json_to_dsl"),b||g.push("sruja_dsl_to_mermaid"),A||g.push("sruja_dsl_to_markdown");const p=Object.keys(e).filter(E=>E.startsWith("sruja_")),y=new Re(`WASM functions not found. Missing: ${g.join(", ")}. Available: ${p.join(", ")||"none"}`,{configKey:"wasm_functions",context:{missing:g,available:p,retries:h}});throw T.error("WASM functions missing",{component:"wasm",action:"init",errorType:"wasm_functions_missing",missing:g,available:p,retries:h,windowKeys:Object.keys(e).filter(E=>E.includes("sruja")||E.includes("wasm")),error:y.message}),y}return{parseDslToJson:async(g,p)=>{try{const y=p||typeof location<"u"&&location.pathname||"input.sruja",E=m(g,y);if(!E||!E.ok){const _=new Error(E?.error||"parse failed");throw T.error("WASM parse failed",{component:"wasm",action:"parse_dsl",errorType:"parse_failure",errorCode:E?.error,dslLength:g.length,error:_.message}),_}return E.json||""}catch(y){throw T.error("WASM parse exception",{component:"wasm",action:"parse_dsl",errorType:"parse_exception",error:y instanceof Error?y.message:String(y)}),y}},printJsonToDsl:async g=>{try{const p=x(g);if(!p||!p.ok){const y=new Error(p?.error||"print failed");throw T.error("WASM print failed",{component:"wasm",action:"print_json",errorType:"print_failure",errorCode:p?.error,jsonLength:g.length,error:y.message}),y}return p.dsl||""}catch(p){throw T.error("WASM print exception",{component:"wasm",action:"print_json",errorType:"print_exception",error:p instanceof Error?p.message:String(p)}),p}},dslToMermaid:async g=>{try{const p=b(g);if(!p||!p.ok)throw new Error(p?.error||"mermaid export failed");return p.data||""}catch(p){throw T.error("WASM mermaid export exception",{component:"wasm",action:"export_mermaid",error:p instanceof Error?p.message:String(p)}),p}},dslToMarkdown:async g=>{try{const p=A(g);if(!p||!p.ok)throw new Error(p?.error||"markdown export failed");return p.data||""}catch(p){throw T.error("WASM markdown export exception",{component:"wasm",action:"export_markdown",error:p instanceof Error?p.message:String(p)}),p}},dslToLikeC4:async(g,p)=>{try{const y=p||typeof location<"u"&&location.pathname||"input.sruja";if(!S)throw new Error("sruja_dsl_to_likec4 function not registered");const E=S(g,y);if(!E||!E.ok)throw new Error(E?.error||"likec4 export failed");return E.data||""}catch(y){throw T.error("WASM likec4 export exception",{component:"wasm",action:"export_likec4",error:y instanceof Error?y.message:String(y)}),y}}}}let Oe=null,ft=null;function Ca(){return _t({trailingSlash:!0,studioPath:!0})}async function Pi(i){return Oe||ft||(ft=(async()=>{const e=Ca();return Oe=await ji({...i,base:e}),Oe})(),ft)}async function an(){if(Oe)return Oe;try{return await Pi()}catch(i){return T.error("Failed to initialize WASM",{component:"wasm",action:"get_api",error:i instanceof Error?i.message:String(i)}),null}}async function Aa(i,e){const t=await an();if(!t)return T.error("WASM not available",{component:"wasm",action:"convert_dsl_to_json"}),null;try{const n=await t.parseDslToJson(i,e);return JSON.parse(n)}catch(n){const r=n instanceof Error?n.message:String(n);throw T.error("DSL parse error",{component:"wasm",action:"convert_dsl_to_json",error:r,filename:"unknown"}),new Error(`Failed to parse DSL: ${r}`)}}async function Ia(i){const e=await an();if(!e)return T.error("WASM not available",{component:"wasm",action:"convert_dsl_to_markdown"}),null;try{return await e.dslToMarkdown(i)}catch(t){return T.error("DSL to Markdown conversion error",{component:"wasm",action:"convert_dsl_to_markdown",error:t instanceof Error?t.message:String(t)}),null}}async function zi(){if(it()){const i=_t(),e=await fetch(`${i}/examples/manifest.json`);if(!e.ok)throw new Error(`Failed to load examples manifest: ${e.status}`);return await e.json()}else{const i="fs/promises",e="path",n=await import(i),r=await import(e),{fileURLToPath:s}=await import("url"),o=s(import.meta.url),a=r.dirname(o),c=r.resolve(a,"../../../../examples/manifest.json"),u=await n.readFile(c,"utf-8");return JSON.parse(u)}}async function Na(i){if(it()){const e=_t(),t=`?v=${Date.now()}&_=${Math.random()}`,n=await fetch(`${e}/examples/${i}${t}`,{cache:"no-store",headers:{"Cache-Control":"no-cache, no-store, must-revalidate",Pragma:"no-cache",Expires:"0"}});if(!n.ok)throw new Error(`Failed to load example file: ${i} (${n.status})`);return await n.text()}else{const e="fs/promises",t="path",r=await import(e),s=await import(t),{fileURLToPath:o}=await import("url"),a=o(import.meta.url),c=s.dirname(a),u=s.resolve(c,"../../../../examples",i);return await r.readFile(u,"utf-8")}}async function Ra(){return(await zi()).examples.filter(e=>!e.skipPlayground).sort((e,t)=>e.order-t.order)}const ja=Object.freeze(Object.defineProperty({__proto__:null,ConfigurationError:Re,DEFAULT_PROJECT_ID:Mr,DEFAULT_PROJECT_NAME:Or,NetworkError:Et,SrujaError:nt,capture:ni,convertDslToJson:Aa,convertDslToMarkdown:Ia,getAvailableExamples:Ra,getBaseUrl:_t,getPosthog:ti,getWasmApi:an,initWasm:ji,initWasmAuto:Pi,isBrowser:it,loadExampleFile:Na,loadExamplesManifest:zi,logger:T},Symbol.toStringTag,{value:"Module"}));export{Mr as D,O as G,Ta as a,Or as b,Ia as c,Na as d,Aa as e,Ra as g,ja as i,T as l};
